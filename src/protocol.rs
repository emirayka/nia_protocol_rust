// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protocol.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeRequest {
    fn default() -> &'a HandshakeRequest {
        <HandshakeRequest as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeRequest {
    pub fn new() -> HandshakeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HandshakeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeRequest {
        HandshakeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeRequest>(
                    "HandshakeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeRequest {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeRequest::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse {
    // message oneof groups
    pub result: ::std::option::Option<HandshakeResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse {
    fn default() -> &'a HandshakeResponse {
        <HandshakeResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HandshakeResponse_oneof_result {
    success_result(HandshakeResponse_SuccessResult),
    error_result(HandshakeResponse_ErrorResult),
}

impl HandshakeResponse {
    pub fn new() -> HandshakeResponse {
        ::std::default::Default::default()
    }

    // .HandshakeResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &HandshakeResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(ref v)) => v,
            _ => HandshakeResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: HandshakeResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut HandshakeResponse_SuccessResult {
        if let ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(HandshakeResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> HandshakeResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse_SuccessResult::new()
        }
    }

    // .HandshakeResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &HandshakeResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(ref v)) => v,
            _ => HandshakeResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: HandshakeResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut HandshakeResponse_ErrorResult {
        if let ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(HandshakeResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> HandshakeResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse_ErrorResult::new()
        }
    }
}

impl ::protobuf::Message for HandshakeResponse {
    fn is_initialized(&self) -> bool {
        if let Some(HandshakeResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HandshakeResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &HandshakeResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HandshakeResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &HandshakeResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HandshakeResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse {
        HandshakeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse_SuccessResult>(
                    "success_result",
                    HandshakeResponse::has_success_result,
                    HandshakeResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse_ErrorResult>(
                    "error_result",
                    HandshakeResponse::has_error_result,
                    HandshakeResponse::get_error_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse>(
                    "HandshakeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse_SuccessResult {
    // message fields
    pub version: ::protobuf::Chars,
    pub info: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse_SuccessResult {
    fn default() -> &'a HandshakeResponse_SuccessResult {
        <HandshakeResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse_SuccessResult {
    pub fn new() -> HandshakeResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        ::protobuf::Clear::clear(&mut self.version);
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::protobuf::Chars) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::protobuf::Chars {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.version, ::protobuf::Chars::new())
    }

    // string info = 2;


    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        ::protobuf::Clear::clear(&mut self.info);
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::protobuf::Chars) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::protobuf::Chars {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.info, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for HandshakeResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.info.is_empty() {
            os.write_string(2, &self.info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse_SuccessResult {
        HandshakeResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "version",
                    |m: &HandshakeResponse_SuccessResult| { &m.version },
                    |m: &mut HandshakeResponse_SuccessResult| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "info",
                    |m: &HandshakeResponse_SuccessResult| { &m.info },
                    |m: &mut HandshakeResponse_SuccessResult| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse_SuccessResult>(
                    "HandshakeResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.version);
        ::protobuf::Clear::clear(&mut self.info);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse_ErrorResult {
    fn default() -> &'a HandshakeResponse_ErrorResult {
        <HandshakeResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse_ErrorResult {
    pub fn new() -> HandshakeResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for HandshakeResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse_ErrorResult {
        HandshakeResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &HandshakeResponse_ErrorResult| { &m.message },
                    |m: &mut HandshakeResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse_ErrorResult>(
                    "HandshakeResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesRequest {
    fn default() -> &'a GetDevicesRequest {
        <GetDevicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesRequest {
    pub fn new() -> GetDevicesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDevicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesRequest {
        GetDevicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesRequest>(
                    "GetDevicesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse {
    // message oneof groups
    pub result: ::std::option::Option<GetDevicesResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse {
    fn default() -> &'a GetDevicesResponse {
        <GetDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetDevicesResponse_oneof_result {
    success_result(GetDevicesResponse_SuccessResult),
    error_result(GetDevicesResponse_ErrorResult),
}

impl GetDevicesResponse {
    pub fn new() -> GetDevicesResponse {
        ::std::default::Default::default()
    }

    // .GetDevicesResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &GetDevicesResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(ref v)) => v,
            _ => GetDevicesResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: GetDevicesResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut GetDevicesResponse_SuccessResult {
        if let ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(GetDevicesResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> GetDevicesResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse_SuccessResult::new()
        }
    }

    // .GetDevicesResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &GetDevicesResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(ref v)) => v,
            _ => GetDevicesResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: GetDevicesResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut GetDevicesResponse_ErrorResult {
        if let ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(GetDevicesResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> GetDevicesResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse_ErrorResult::new()
        }
    }
}

impl ::protobuf::Message for GetDevicesResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetDevicesResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDevicesResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDevicesResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDevicesResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDevicesResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDevicesResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse {
        GetDevicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse_SuccessResult>(
                    "success_result",
                    GetDevicesResponse::has_success_result,
                    GetDevicesResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse_ErrorResult>(
                    "error_result",
                    GetDevicesResponse::has_error_result,
                    GetDevicesResponse::get_error_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse>(
                    "GetDevicesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse_SuccessResult {
    // message fields
    pub devices: ::std::vec::Vec<::protobuf::Chars>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse_SuccessResult {
    fn default() -> &'a GetDevicesResponse_SuccessResult {
        <GetDevicesResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesResponse_SuccessResult {
    pub fn new() -> GetDevicesResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // repeated string devices = 1;


    pub fn get_devices(&self) -> &[::protobuf::Chars] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<::protobuf::Chars>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<::protobuf::Chars> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<::protobuf::Chars> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetDevicesResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_carllerche_string_into(wire_type, is, &mut self.devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.devices {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.devices {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse_SuccessResult {
        GetDevicesResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "devices",
                    |m: &GetDevicesResponse_SuccessResult| { &m.devices },
                    |m: &mut GetDevicesResponse_SuccessResult| { &mut m.devices },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse_SuccessResult>(
                    "GetDevicesResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse_SuccessResult {
    fn clear(&mut self) {
        self.devices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse_ErrorResult {
    fn default() -> &'a GetDevicesResponse_ErrorResult {
        <GetDevicesResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesResponse_ErrorResult {
    pub fn new() -> GetDevicesResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDevicesResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse_ErrorResult {
        GetDevicesResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDevicesResponse_ErrorResult| { &m.message },
                    |m: &mut GetDevicesResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse_ErrorResult>(
                    "GetDevicesResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceInfoRequest {
    // message fields
    pub device: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceInfoRequest {
    fn default() -> &'a GetDeviceInfoRequest {
        <GetDeviceInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceInfoRequest {
    pub fn new() -> GetDeviceInfoRequest {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        ::protobuf::Clear::clear(&mut self.device);
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::protobuf::Chars) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::protobuf::Chars {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.device, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDeviceInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceInfoRequest {
        GetDeviceInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "device",
                    |m: &GetDeviceInfoRequest| { &m.device },
                    |m: &mut GetDeviceInfoRequest| { &mut m.device },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceInfoRequest>(
                    "GetDeviceInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceInfoRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDeviceInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceInfoRequest {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.device);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceInfoResponse {
    // message oneof groups
    pub result: ::std::option::Option<GetDeviceInfoResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceInfoResponse {
    fn default() -> &'a GetDeviceInfoResponse {
        <GetDeviceInfoResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetDeviceInfoResponse_oneof_result {
    success_result(GetDeviceInfoResponse_SuccessResult),
    error_result(GetDeviceInfoResponse_ErrorResult),
}

impl GetDeviceInfoResponse {
    pub fn new() -> GetDeviceInfoResponse {
        ::std::default::Default::default()
    }

    // .GetDeviceInfoResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &GetDeviceInfoResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(ref v)) => v,
            _ => GetDeviceInfoResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: GetDeviceInfoResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut GetDeviceInfoResponse_SuccessResult {
        if let ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(GetDeviceInfoResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> GetDeviceInfoResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDeviceInfoResponse_SuccessResult::new()
        }
    }

    // .GetDeviceInfoResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &GetDeviceInfoResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(ref v)) => v,
            _ => GetDeviceInfoResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: GetDeviceInfoResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut GetDeviceInfoResponse_ErrorResult {
        if let ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(GetDeviceInfoResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> GetDeviceInfoResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDeviceInfoResponse_ErrorResult::new()
        }
    }
}

impl ::protobuf::Message for GetDeviceInfoResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetDeviceInfoResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDeviceInfoResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDeviceInfoResponse_oneof_result::error_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDeviceInfoResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDeviceInfoResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDeviceInfoResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDeviceInfoResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceInfoResponse {
        GetDeviceInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDeviceInfoResponse_SuccessResult>(
                    "success_result",
                    GetDeviceInfoResponse::has_success_result,
                    GetDeviceInfoResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDeviceInfoResponse_ErrorResult>(
                    "error_result",
                    GetDeviceInfoResponse::has_error_result,
                    GetDeviceInfoResponse::get_error_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceInfoResponse>(
                    "GetDeviceInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceInfoResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDeviceInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceInfoResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceInfoResponse_SuccessResult {
    // message fields
    pub device: ::protobuf::Chars,
    pub name: ::protobuf::Chars,
    pub model: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceInfoResponse_SuccessResult {
    fn default() -> &'a GetDeviceInfoResponse_SuccessResult {
        <GetDeviceInfoResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceInfoResponse_SuccessResult {
    pub fn new() -> GetDeviceInfoResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        ::protobuf::Clear::clear(&mut self.device);
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::protobuf::Chars) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::protobuf::Chars {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.device, ::protobuf::Chars::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.name);
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.name, ::protobuf::Chars::new())
    }

    // string model = 3;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        ::protobuf::Clear::clear(&mut self.model);
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::protobuf::Chars) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::protobuf::Chars {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.model, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDeviceInfoResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.device)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.model.is_empty() {
            os.write_string(3, &self.model)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceInfoResponse_SuccessResult {
        GetDeviceInfoResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "device",
                    |m: &GetDeviceInfoResponse_SuccessResult| { &m.device },
                    |m: &mut GetDeviceInfoResponse_SuccessResult| { &mut m.device },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "name",
                    |m: &GetDeviceInfoResponse_SuccessResult| { &m.name },
                    |m: &mut GetDeviceInfoResponse_SuccessResult| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "model",
                    |m: &GetDeviceInfoResponse_SuccessResult| { &m.model },
                    |m: &mut GetDeviceInfoResponse_SuccessResult| { &mut m.model },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceInfoResponse_SuccessResult>(
                    "GetDeviceInfoResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceInfoResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceInfoResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDeviceInfoResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceInfoResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.device);
        ::protobuf::Clear::clear(&mut self.name);
        ::protobuf::Clear::clear(&mut self.model);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceInfoResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceInfoResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceInfoResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceInfoResponse_ErrorResult {
    fn default() -> &'a GetDeviceInfoResponse_ErrorResult {
        <GetDeviceInfoResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceInfoResponse_ErrorResult {
    pub fn new() -> GetDeviceInfoResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDeviceInfoResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceInfoResponse_ErrorResult {
        GetDeviceInfoResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDeviceInfoResponse_ErrorResult| { &m.message },
                    |m: &mut GetDeviceInfoResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceInfoResponse_ErrorResult>(
                    "GetDeviceInfoResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceInfoResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceInfoResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDeviceInfoResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceInfoResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceInfoResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceInfoResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeRequest {
    // message fields
    pub code: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeRequest {
    fn default() -> &'a ExecuteCodeRequest {
        <ExecuteCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeRequest {
    pub fn new() -> ExecuteCodeRequest {
        ::std::default::Default::default()
    }

    // string code = 1;


    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        ::protobuf::Clear::clear(&mut self.code);
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::protobuf::Chars) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::protobuf::Chars {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.code, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeRequest {
        ExecuteCodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "code",
                    |m: &ExecuteCodeRequest| { &m.code },
                    |m: &mut ExecuteCodeRequest| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeRequest>(
                    "ExecuteCodeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeRequest {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.code);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse {
    // message oneof groups
    pub result: ::std::option::Option<ExecuteCodeResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse {
    fn default() -> &'a ExecuteCodeResponse {
        <ExecuteCodeResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExecuteCodeResponse_oneof_result {
    success_result(ExecuteCodeResponse_SuccessResult),
    error_result(ExecuteCodeResponse_ErrorResult),
    failure_result(ExecuteCodeResponse_FailureResult),
}

impl ExecuteCodeResponse {
    pub fn new() -> ExecuteCodeResponse {
        ::std::default::Default::default()
    }

    // .ExecuteCodeResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &ExecuteCodeResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(ref v)) => v,
            _ => ExecuteCodeResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: ExecuteCodeResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut ExecuteCodeResponse_SuccessResult {
        if let ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(ExecuteCodeResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> ExecuteCodeResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse_SuccessResult::new()
        }
    }

    // .ExecuteCodeResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &ExecuteCodeResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(ref v)) => v,
            _ => ExecuteCodeResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: ExecuteCodeResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut ExecuteCodeResponse_ErrorResult {
        if let ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(ExecuteCodeResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> ExecuteCodeResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse_ErrorResult::new()
        }
    }

    // .ExecuteCodeResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &ExecuteCodeResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(ref v)) => v,
            _ => ExecuteCodeResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: ExecuteCodeResponse_FailureResult) {
        self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut ExecuteCodeResponse_FailureResult {
        if let ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(ExecuteCodeResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> ExecuteCodeResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for ExecuteCodeResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ExecuteCodeResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExecuteCodeResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExecuteCodeResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &ExecuteCodeResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExecuteCodeResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExecuteCodeResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &ExecuteCodeResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExecuteCodeResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExecuteCodeResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse {
        ExecuteCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse_SuccessResult>(
                    "success_result",
                    ExecuteCodeResponse::has_success_result,
                    ExecuteCodeResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse_ErrorResult>(
                    "error_result",
                    ExecuteCodeResponse::has_error_result,
                    ExecuteCodeResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse_FailureResult>(
                    "failure_result",
                    ExecuteCodeResponse::has_failure_result,
                    ExecuteCodeResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse>(
                    "ExecuteCodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse_SuccessResult {
    // message fields
    pub execution_result: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse_SuccessResult {
    fn default() -> &'a ExecuteCodeResponse_SuccessResult {
        <ExecuteCodeResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeResponse_SuccessResult {
    pub fn new() -> ExecuteCodeResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string execution_result = 1;


    pub fn get_execution_result(&self) -> &str {
        &self.execution_result
    }
    pub fn clear_execution_result(&mut self) {
        ::protobuf::Clear::clear(&mut self.execution_result);
    }

    // Param is passed by value, moved
    pub fn set_execution_result(&mut self, v: ::protobuf::Chars) {
        self.execution_result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_result(&mut self) -> &mut ::protobuf::Chars {
        &mut self.execution_result
    }

    // Take field
    pub fn take_execution_result(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.execution_result, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.execution_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.execution_result.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.execution_result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.execution_result.is_empty() {
            os.write_string(1, &self.execution_result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse_SuccessResult {
        ExecuteCodeResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "execution_result",
                    |m: &ExecuteCodeResponse_SuccessResult| { &m.execution_result },
                    |m: &mut ExecuteCodeResponse_SuccessResult| { &mut m.execution_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse_SuccessResult>(
                    "ExecuteCodeResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.execution_result);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse_ErrorResult {
    fn default() -> &'a ExecuteCodeResponse_ErrorResult {
        <ExecuteCodeResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeResponse_ErrorResult {
    pub fn new() -> ExecuteCodeResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse_ErrorResult {
        ExecuteCodeResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ExecuteCodeResponse_ErrorResult| { &m.message },
                    |m: &mut ExecuteCodeResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse_ErrorResult>(
                    "ExecuteCodeResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse_FailureResult {
    fn default() -> &'a ExecuteCodeResponse_FailureResult {
        <ExecuteCodeResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeResponse_FailureResult {
    pub fn new() -> ExecuteCodeResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse_FailureResult {
        ExecuteCodeResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ExecuteCodeResponse_FailureResult| { &m.message },
                    |m: &mut ExecuteCodeResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse_FailureResult>(
                    "ExecuteCodeResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message oneof groups
    pub request: ::std::option::Option<Request_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Request_oneof_request {
    handshake_request(HandshakeRequest),
    get_devices_request(GetDevicesRequest),
    get_device_info_request(GetDeviceInfoRequest),
    execute_code_request(ExecuteCodeRequest),
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // .HandshakeRequest handshake_request = 1;


    pub fn get_handshake_request(&self) -> &HandshakeRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::handshake_request(ref v)) => v,
            _ => HandshakeRequest::default_instance(),
        }
    }
    pub fn clear_handshake_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_handshake_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::handshake_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake_request(&mut self, v: HandshakeRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::handshake_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake_request(&mut self) -> &mut HandshakeRequest {
        if let ::std::option::Option::Some(Request_oneof_request::handshake_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::handshake_request(HandshakeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::handshake_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake_request(&mut self) -> HandshakeRequest {
        if self.has_handshake_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::handshake_request(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeRequest::new()
        }
    }

    // .GetDevicesRequest get_devices_request = 2;


    pub fn get_get_devices_request(&self) -> &GetDevicesRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_devices_request(ref v)) => v,
            _ => GetDevicesRequest::default_instance(),
        }
    }
    pub fn clear_get_devices_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_devices_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_devices_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_devices_request(&mut self, v: GetDevicesRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::get_devices_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_devices_request(&mut self) -> &mut GetDevicesRequest {
        if let ::std::option::Option::Some(Request_oneof_request::get_devices_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::get_devices_request(GetDevicesRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_devices_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_devices_request(&mut self) -> GetDevicesRequest {
        if self.has_get_devices_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::get_devices_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesRequest::new()
        }
    }

    // .GetDeviceInfoRequest get_device_info_request = 3;


    pub fn get_get_device_info_request(&self) -> &GetDeviceInfoRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_device_info_request(ref v)) => v,
            _ => GetDeviceInfoRequest::default_instance(),
        }
    }
    pub fn clear_get_device_info_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_device_info_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_device_info_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_device_info_request(&mut self, v: GetDeviceInfoRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::get_device_info_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_device_info_request(&mut self) -> &mut GetDeviceInfoRequest {
        if let ::std::option::Option::Some(Request_oneof_request::get_device_info_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::get_device_info_request(GetDeviceInfoRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_device_info_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_device_info_request(&mut self) -> GetDeviceInfoRequest {
        if self.has_get_device_info_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::get_device_info_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDeviceInfoRequest::new()
        }
    }

    // .ExecuteCodeRequest execute_code_request = 4;


    pub fn get_execute_code_request(&self) -> &ExecuteCodeRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::execute_code_request(ref v)) => v,
            _ => ExecuteCodeRequest::default_instance(),
        }
    }
    pub fn clear_execute_code_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_execute_code_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::execute_code_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execute_code_request(&mut self, v: ExecuteCodeRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::execute_code_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execute_code_request(&mut self) -> &mut ExecuteCodeRequest {
        if let ::std::option::Option::Some(Request_oneof_request::execute_code_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::execute_code_request(ExecuteCodeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::execute_code_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execute_code_request(&mut self) -> ExecuteCodeRequest {
        if self.has_execute_code_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::execute_code_request(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeRequest::new()
        }
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        if let Some(Request_oneof_request::handshake_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::get_devices_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::get_device_info_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::execute_code_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::handshake_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::get_devices_request(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::get_device_info_request(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::execute_code_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Request_oneof_request::handshake_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::get_devices_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::get_device_info_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::execute_code_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Request_oneof_request::handshake_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::get_devices_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::get_device_info_request(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::execute_code_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeRequest>(
                    "handshake_request",
                    Request::has_handshake_request,
                    Request::get_handshake_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesRequest>(
                    "get_devices_request",
                    Request::has_get_devices_request,
                    Request::get_get_devices_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDeviceInfoRequest>(
                    "get_device_info_request",
                    Request::has_get_device_info_request,
                    Request::get_get_device_info_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeRequest>(
                    "execute_code_request",
                    Request::has_execute_code_request,
                    Request::get_execute_code_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Request::new)
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message oneof groups
    pub request: ::std::option::Option<Response_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Response_oneof_request {
    handshake_response(HandshakeResponse),
    get_devices_response(GetDevicesResponse),
    get_device_info_response(GetDeviceInfoResponse),
    execute_code_response(ExecuteCodeResponse),
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .HandshakeResponse handshake_response = 1;


    pub fn get_handshake_response(&self) -> &HandshakeResponse {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::handshake_response(ref v)) => v,
            _ => HandshakeResponse::default_instance(),
        }
    }
    pub fn clear_handshake_response(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_handshake_response(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::handshake_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake_response(&mut self, v: HandshakeResponse) {
        self.request = ::std::option::Option::Some(Response_oneof_request::handshake_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake_response(&mut self) -> &mut HandshakeResponse {
        if let ::std::option::Option::Some(Response_oneof_request::handshake_response(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Response_oneof_request::handshake_response(HandshakeResponse::new()));
        }
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::handshake_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake_response(&mut self) -> HandshakeResponse {
        if self.has_handshake_response() {
            match self.request.take() {
                ::std::option::Option::Some(Response_oneof_request::handshake_response(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse::new()
        }
    }

    // .GetDevicesResponse get_devices_response = 2;


    pub fn get_get_devices_response(&self) -> &GetDevicesResponse {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::get_devices_response(ref v)) => v,
            _ => GetDevicesResponse::default_instance(),
        }
    }
    pub fn clear_get_devices_response(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_devices_response(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::get_devices_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_devices_response(&mut self, v: GetDevicesResponse) {
        self.request = ::std::option::Option::Some(Response_oneof_request::get_devices_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_devices_response(&mut self) -> &mut GetDevicesResponse {
        if let ::std::option::Option::Some(Response_oneof_request::get_devices_response(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Response_oneof_request::get_devices_response(GetDevicesResponse::new()));
        }
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::get_devices_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_devices_response(&mut self) -> GetDevicesResponse {
        if self.has_get_devices_response() {
            match self.request.take() {
                ::std::option::Option::Some(Response_oneof_request::get_devices_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse::new()
        }
    }

    // .GetDeviceInfoResponse get_device_info_response = 3;


    pub fn get_get_device_info_response(&self) -> &GetDeviceInfoResponse {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::get_device_info_response(ref v)) => v,
            _ => GetDeviceInfoResponse::default_instance(),
        }
    }
    pub fn clear_get_device_info_response(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_device_info_response(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::get_device_info_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_device_info_response(&mut self, v: GetDeviceInfoResponse) {
        self.request = ::std::option::Option::Some(Response_oneof_request::get_device_info_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_device_info_response(&mut self) -> &mut GetDeviceInfoResponse {
        if let ::std::option::Option::Some(Response_oneof_request::get_device_info_response(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Response_oneof_request::get_device_info_response(GetDeviceInfoResponse::new()));
        }
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::get_device_info_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_device_info_response(&mut self) -> GetDeviceInfoResponse {
        if self.has_get_device_info_response() {
            match self.request.take() {
                ::std::option::Option::Some(Response_oneof_request::get_device_info_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDeviceInfoResponse::new()
        }
    }

    // .ExecuteCodeResponse execute_code_response = 4;


    pub fn get_execute_code_response(&self) -> &ExecuteCodeResponse {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::execute_code_response(ref v)) => v,
            _ => ExecuteCodeResponse::default_instance(),
        }
    }
    pub fn clear_execute_code_response(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_execute_code_response(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::execute_code_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execute_code_response(&mut self, v: ExecuteCodeResponse) {
        self.request = ::std::option::Option::Some(Response_oneof_request::execute_code_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execute_code_response(&mut self) -> &mut ExecuteCodeResponse {
        if let ::std::option::Option::Some(Response_oneof_request::execute_code_response(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Response_oneof_request::execute_code_response(ExecuteCodeResponse::new()));
        }
        match self.request {
            ::std::option::Option::Some(Response_oneof_request::execute_code_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execute_code_response(&mut self) -> ExecuteCodeResponse {
        if self.has_execute_code_response() {
            match self.request.take() {
                ::std::option::Option::Some(Response_oneof_request::execute_code_response(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse::new()
        }
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        if let Some(Response_oneof_request::handshake_response(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_request::get_devices_response(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_request::get_device_info_response(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_request::execute_code_response(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Response_oneof_request::handshake_response(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Response_oneof_request::get_devices_response(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Response_oneof_request::get_device_info_response(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Response_oneof_request::execute_code_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Response_oneof_request::handshake_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_request::get_devices_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_request::get_device_info_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_request::execute_code_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Response_oneof_request::handshake_response(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_request::get_devices_response(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_request::get_device_info_response(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_request::execute_code_response(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse>(
                    "handshake_response",
                    Response::has_handshake_response,
                    Response::get_handshake_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse>(
                    "get_devices_response",
                    Response::has_get_devices_response,
                    Response::get_get_devices_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDeviceInfoResponse>(
                    "get_device_info_response",
                    Response::has_get_device_info_response,
                    Response::get_get_device_info_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse>(
                    "execute_code_response",
                    Response::has_execute_code_response,
                    Response::get_execute_code_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eprotocol.proto\"\x12\n\x10HandshakeRequest\"\x95\x02\n\x11Handshak\
    eResponse\x12I\n\x0esuccess_result\x18\x01\x20\x01(\x0b2\x20.HandshakeRe\
    sponse.SuccessResultH\0R\rsuccessResult\x12C\n\x0cerror_result\x18\x02\
    \x20\x01(\x0b2\x1e.HandshakeResponse.ErrorResultH\0R\x0berrorResult\x1a=\
    \n\rSuccessResult\x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07version\
    \x12\x12\n\x04info\x18\x02\x20\x01(\tR\x04info\x1a'\n\x0bErrorResult\x12\
    \x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"\x13\
    \n\x11GetDevicesRequest\"\x84\x02\n\x12GetDevicesResponse\x12J\n\x0esucc\
    ess_result\x18\x01\x20\x01(\x0b2!.GetDevicesResponse.SuccessResultH\0R\r\
    successResult\x12D\n\x0cerror_result\x18\x02\x20\x01(\x0b2\x1f.GetDevice\
    sResponse.ErrorResultH\0R\x0berrorResult\x1a)\n\rSuccessResult\x12\x18\n\
    \x07devices\x18\x01\x20\x03(\tR\x07devices\x1a'\n\x0bErrorResult\x12\x18\
    \n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\".\n\x14Ge\
    tDeviceInfoRequest\x12\x16\n\x06device\x18\x01\x20\x01(\tR\x06device\"\
    \xb5\x02\n\x15GetDeviceInfoResponse\x12M\n\x0esuccess_result\x18\x01\x20\
    \x01(\x0b2$.GetDeviceInfoResponse.SuccessResultH\0R\rsuccessResult\x12G\
    \n\x0cerror_result\x18\x02\x20\x01(\x0b2\".GetDeviceInfoResponse.ErrorRe\
    sultH\0R\x0berrorResult\x1aQ\n\rSuccessResult\x12\x16\n\x06device\x18\
    \x01\x20\x01(\tR\x06device\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x14\n\x05model\x18\x03\x20\x01(\tR\x05model\x1a'\n\x0bErrorResult\
    \x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"(\
    \n\x12ExecuteCodeRequest\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\"\
    \x90\x03\n\x13ExecuteCodeResponse\x12K\n\x0esuccess_result\x18\x01\x20\
    \x01(\x0b2\".ExecuteCodeResponse.SuccessResultH\0R\rsuccessResult\x12E\n\
    \x0cerror_result\x18\x02\x20\x01(\x0b2\x20.ExecuteCodeResponse.ErrorResu\
    ltH\0R\x0berrorResult\x12K\n\x0efailure_result\x18\x03\x20\x01(\x0b2\".E\
    xecuteCodeResponse.FailureResultH\0R\rfailureResult\x1a:\n\rSuccessResul\
    t\x12)\n\x10execution_result\x18\x01\x20\x01(\tR\x0fexecutionResult\x1a'\
    \n\x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\
    \x1a)\n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messa\
    geB\x08\n\x06result\"\xb5\x02\n\x07Request\x12@\n\x11handshake_request\
    \x18\x01\x20\x01(\x0b2\x11.HandshakeRequestH\0R\x10handshakeRequest\x12D\
    \n\x13get_devices_request\x18\x02\x20\x01(\x0b2\x12.GetDevicesRequestH\0\
    R\x11getDevicesRequest\x12N\n\x17get_device_info_request\x18\x03\x20\x01\
    (\x0b2\x15.GetDeviceInfoRequestH\0R\x14getDeviceInfoRequest\x12G\n\x14ex\
    ecute_code_request\x18\x04\x20\x01(\x0b2\x13.ExecuteCodeRequestH\0R\x12e\
    xecuteCodeRequestB\t\n\x07request\"\xc2\x02\n\x08Response\x12C\n\x12hand\
    shake_response\x18\x01\x20\x01(\x0b2\x12.HandshakeResponseH\0R\x11handsh\
    akeResponse\x12G\n\x14get_devices_response\x18\x02\x20\x01(\x0b2\x13.Get\
    DevicesResponseH\0R\x12getDevicesResponse\x12Q\n\x18get_device_info_resp\
    onse\x18\x03\x20\x01(\x0b2\x16.GetDeviceInfoResponseH\0R\x15getDeviceInf\
    oResponse\x12J\n\x15execute_code_response\x18\x04\x20\x01(\x0b2\x14.Exec\
    uteCodeResponseH\0R\x13executeCodeResponseB\t\n\x07requestb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
