// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protocol.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct ActionKeyPress {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionKeyPress {
    fn default() -> &'a ActionKeyPress {
        <ActionKeyPress as ::protobuf::Message>::default_instance()
    }
}

impl ActionKeyPress {
    pub fn new() -> ActionKeyPress {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionKeyPress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionKeyPress {
        ActionKeyPress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionKeyPress| { &m.key_code },
                    |m: &mut ActionKeyPress| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionKeyPress>(
                    "ActionKeyPress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionKeyPress {
        static mut instance: ::protobuf::lazy::Lazy<ActionKeyPress> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionKeyPress::new)
        }
    }
}

impl ::protobuf::Clear for ActionKeyPress {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionKeyPress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionKeyPress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionKeyClick {
    fn default() -> &'a ActionKeyClick {
        <ActionKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionKeyClick {
    pub fn new() -> ActionKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionKeyClick {
        ActionKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionKeyClick| { &m.key_code },
                    |m: &mut ActionKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionKeyClick>(
                    "ActionKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionKeyRelease {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionKeyRelease {
    fn default() -> &'a ActionKeyRelease {
        <ActionKeyRelease as ::protobuf::Message>::default_instance()
    }
}

impl ActionKeyRelease {
    pub fn new() -> ActionKeyRelease {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionKeyRelease {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionKeyRelease {
        ActionKeyRelease::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionKeyRelease| { &m.key_code },
                    |m: &mut ActionKeyRelease| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionKeyRelease>(
                    "ActionKeyRelease",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionKeyRelease {
        static mut instance: ::protobuf::lazy::Lazy<ActionKeyRelease> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionKeyRelease::new)
        }
    }
}

impl ::protobuf::Clear for ActionKeyRelease {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionKeyRelease {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionKeyRelease {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMouseButtonPress {
    // message fields
    pub button_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMouseButtonPress {
    fn default() -> &'a ActionMouseButtonPress {
        <ActionMouseButtonPress as ::protobuf::Message>::default_instance()
    }
}

impl ActionMouseButtonPress {
    pub fn new() -> ActionMouseButtonPress {
        ::std::default::Default::default()
    }

    // int32 button_code = 1;


    pub fn get_button_code(&self) -> i32 {
        self.button_code
    }
    pub fn clear_button_code(&mut self) {
        self.button_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_button_code(&mut self, v: i32) {
        self.button_code = v;
    }
}

impl ::protobuf::Message for ActionMouseButtonPress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.button_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.button_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.button_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.button_code != 0 {
            os.write_int32(1, self.button_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMouseButtonPress {
        ActionMouseButtonPress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "button_code",
                    |m: &ActionMouseButtonPress| { &m.button_code },
                    |m: &mut ActionMouseButtonPress| { &mut m.button_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMouseButtonPress>(
                    "ActionMouseButtonPress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMouseButtonPress {
        static mut instance: ::protobuf::lazy::Lazy<ActionMouseButtonPress> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMouseButtonPress::new)
        }
    }
}

impl ::protobuf::Clear for ActionMouseButtonPress {
    fn clear(&mut self) {
        self.button_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMouseButtonPress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMouseButtonPress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMouseButtonClick {
    // message fields
    pub button_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMouseButtonClick {
    fn default() -> &'a ActionMouseButtonClick {
        <ActionMouseButtonClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionMouseButtonClick {
    pub fn new() -> ActionMouseButtonClick {
        ::std::default::Default::default()
    }

    // int32 button_code = 1;


    pub fn get_button_code(&self) -> i32 {
        self.button_code
    }
    pub fn clear_button_code(&mut self) {
        self.button_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_button_code(&mut self, v: i32) {
        self.button_code = v;
    }
}

impl ::protobuf::Message for ActionMouseButtonClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.button_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.button_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.button_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.button_code != 0 {
            os.write_int32(1, self.button_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMouseButtonClick {
        ActionMouseButtonClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "button_code",
                    |m: &ActionMouseButtonClick| { &m.button_code },
                    |m: &mut ActionMouseButtonClick| { &mut m.button_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMouseButtonClick>(
                    "ActionMouseButtonClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMouseButtonClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionMouseButtonClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMouseButtonClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionMouseButtonClick {
    fn clear(&mut self) {
        self.button_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMouseButtonClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMouseButtonClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMouseButtonRelease {
    // message fields
    pub button_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMouseButtonRelease {
    fn default() -> &'a ActionMouseButtonRelease {
        <ActionMouseButtonRelease as ::protobuf::Message>::default_instance()
    }
}

impl ActionMouseButtonRelease {
    pub fn new() -> ActionMouseButtonRelease {
        ::std::default::Default::default()
    }

    // int32 button_code = 1;


    pub fn get_button_code(&self) -> i32 {
        self.button_code
    }
    pub fn clear_button_code(&mut self) {
        self.button_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_button_code(&mut self, v: i32) {
        self.button_code = v;
    }
}

impl ::protobuf::Message for ActionMouseButtonRelease {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.button_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.button_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.button_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.button_code != 0 {
            os.write_int32(1, self.button_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMouseButtonRelease {
        ActionMouseButtonRelease::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "button_code",
                    |m: &ActionMouseButtonRelease| { &m.button_code },
                    |m: &mut ActionMouseButtonRelease| { &mut m.button_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMouseButtonRelease>(
                    "ActionMouseButtonRelease",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMouseButtonRelease {
        static mut instance: ::protobuf::lazy::Lazy<ActionMouseButtonRelease> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMouseButtonRelease::new)
        }
    }
}

impl ::protobuf::Clear for ActionMouseButtonRelease {
    fn clear(&mut self) {
        self.button_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMouseButtonRelease {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMouseButtonRelease {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionTextKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionTextKeyClick {
    fn default() -> &'a ActionTextKeyClick {
        <ActionTextKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionTextKeyClick {
    pub fn new() -> ActionTextKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionTextKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionTextKeyClick {
        ActionTextKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionTextKeyClick| { &m.key_code },
                    |m: &mut ActionTextKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionTextKeyClick>(
                    "ActionTextKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionTextKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionTextKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionTextKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionTextKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionTextKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionTextKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionNumberKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionNumberKeyClick {
    fn default() -> &'a ActionNumberKeyClick {
        <ActionNumberKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionNumberKeyClick {
    pub fn new() -> ActionNumberKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionNumberKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionNumberKeyClick {
        ActionNumberKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionNumberKeyClick| { &m.key_code },
                    |m: &mut ActionNumberKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionNumberKeyClick>(
                    "ActionNumberKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionNumberKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionNumberKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionNumberKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionNumberKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionNumberKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionNumberKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionFunctionKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionFunctionKeyClick {
    fn default() -> &'a ActionFunctionKeyClick {
        <ActionFunctionKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionFunctionKeyClick {
    pub fn new() -> ActionFunctionKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionFunctionKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionFunctionKeyClick {
        ActionFunctionKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionFunctionKeyClick| { &m.key_code },
                    |m: &mut ActionFunctionKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionFunctionKeyClick>(
                    "ActionFunctionKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionFunctionKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionFunctionKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionFunctionKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionFunctionKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionFunctionKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionFunctionKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionControlKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionControlKeyClick {
    fn default() -> &'a ActionControlKeyClick {
        <ActionControlKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionControlKeyClick {
    pub fn new() -> ActionControlKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionControlKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionControlKeyClick {
        ActionControlKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionControlKeyClick| { &m.key_code },
                    |m: &mut ActionControlKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionControlKeyClick>(
                    "ActionControlKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionControlKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionControlKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionControlKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionControlKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionControlKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionControlKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionKPKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionKPKeyClick {
    fn default() -> &'a ActionKPKeyClick {
        <ActionKPKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionKPKeyClick {
    pub fn new() -> ActionKPKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionKPKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionKPKeyClick {
        ActionKPKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionKPKeyClick| { &m.key_code },
                    |m: &mut ActionKPKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionKPKeyClick>(
                    "ActionKPKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionKPKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionKPKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionKPKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionKPKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionKPKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionKPKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMultimediaKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMultimediaKeyClick {
    fn default() -> &'a ActionMultimediaKeyClick {
        <ActionMultimediaKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionMultimediaKeyClick {
    pub fn new() -> ActionMultimediaKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionMultimediaKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMultimediaKeyClick {
        ActionMultimediaKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionMultimediaKeyClick| { &m.key_code },
                    |m: &mut ActionMultimediaKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMultimediaKeyClick>(
                    "ActionMultimediaKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMultimediaKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionMultimediaKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMultimediaKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionMultimediaKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMultimediaKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMultimediaKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMouseButtonKeyClick {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMouseButtonKeyClick {
    fn default() -> &'a ActionMouseButtonKeyClick {
        <ActionMouseButtonKeyClick as ::protobuf::Message>::default_instance()
    }
}

impl ActionMouseButtonKeyClick {
    pub fn new() -> ActionMouseButtonKeyClick {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for ActionMouseButtonKeyClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMouseButtonKeyClick {
        ActionMouseButtonKeyClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &ActionMouseButtonKeyClick| { &m.key_code },
                    |m: &mut ActionMouseButtonKeyClick| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMouseButtonKeyClick>(
                    "ActionMouseButtonKeyClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMouseButtonKeyClick {
        static mut instance: ::protobuf::lazy::Lazy<ActionMouseButtonKeyClick> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMouseButtonKeyClick::new)
        }
    }
}

impl ::protobuf::Clear for ActionMouseButtonKeyClick {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMouseButtonKeyClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMouseButtonKeyClick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMouseRelativeMove {
    // message fields
    pub dx: i32,
    pub dy: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMouseRelativeMove {
    fn default() -> &'a ActionMouseRelativeMove {
        <ActionMouseRelativeMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionMouseRelativeMove {
    pub fn new() -> ActionMouseRelativeMove {
        ::std::default::Default::default()
    }

    // int32 dx = 1;


    pub fn get_dx(&self) -> i32 {
        self.dx
    }
    pub fn clear_dx(&mut self) {
        self.dx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dx(&mut self, v: i32) {
        self.dx = v;
    }

    // int32 dy = 2;


    pub fn get_dy(&self) -> i32 {
        self.dy
    }
    pub fn clear_dy(&mut self) {
        self.dy = 0;
    }

    // Param is passed by value, moved
    pub fn set_dy(&mut self, v: i32) {
        self.dy = v;
    }
}

impl ::protobuf::Message for ActionMouseRelativeMove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dx = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dy != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dy, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dx != 0 {
            os.write_int32(1, self.dx)?;
        }
        if self.dy != 0 {
            os.write_int32(2, self.dy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMouseRelativeMove {
        ActionMouseRelativeMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dx",
                    |m: &ActionMouseRelativeMove| { &m.dx },
                    |m: &mut ActionMouseRelativeMove| { &mut m.dx },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dy",
                    |m: &ActionMouseRelativeMove| { &m.dy },
                    |m: &mut ActionMouseRelativeMove| { &mut m.dy },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMouseRelativeMove>(
                    "ActionMouseRelativeMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMouseRelativeMove {
        static mut instance: ::protobuf::lazy::Lazy<ActionMouseRelativeMove> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMouseRelativeMove::new)
        }
    }
}

impl ::protobuf::Clear for ActionMouseRelativeMove {
    fn clear(&mut self) {
        self.dx = 0;
        self.dy = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMouseRelativeMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMouseRelativeMove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMouseAbsoluteMove {
    // message fields
    pub x: i32,
    pub y: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMouseAbsoluteMove {
    fn default() -> &'a ActionMouseAbsoluteMove {
        <ActionMouseAbsoluteMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionMouseAbsoluteMove {
    pub fn new() -> ActionMouseAbsoluteMove {
        ::std::default::Default::default()
    }

    // int32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = v;
    }

    // int32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = v;
    }
}

impl ::protobuf::Message for ActionMouseAbsoluteMove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_size(1, self.x, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_size(2, self.y, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMouseAbsoluteMove {
        ActionMouseAbsoluteMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &ActionMouseAbsoluteMove| { &m.x },
                    |m: &mut ActionMouseAbsoluteMove| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &ActionMouseAbsoluteMove| { &m.y },
                    |m: &mut ActionMouseAbsoluteMove| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMouseAbsoluteMove>(
                    "ActionMouseAbsoluteMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionMouseAbsoluteMove {
        static mut instance: ::protobuf::lazy::Lazy<ActionMouseAbsoluteMove> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionMouseAbsoluteMove::new)
        }
    }
}

impl ::protobuf::Clear for ActionMouseAbsoluteMove {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMouseAbsoluteMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMouseAbsoluteMove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionWait {
    // message fields
    pub ms: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionWait {
    fn default() -> &'a ActionWait {
        <ActionWait as ::protobuf::Message>::default_instance()
    }
}

impl ActionWait {
    pub fn new() -> ActionWait {
        ::std::default::Default::default()
    }

    // int32 ms = 1;


    pub fn get_ms(&self) -> i32 {
        self.ms
    }
    pub fn clear_ms(&mut self) {
        self.ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_ms(&mut self, v: i32) {
        self.ms = v;
    }
}

impl ::protobuf::Message for ActionWait {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ms = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ms != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ms, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ms != 0 {
            os.write_int32(1, self.ms)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionWait {
        ActionWait::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ms",
                    |m: &ActionWait| { &m.ms },
                    |m: &mut ActionWait| { &mut m.ms },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionWait>(
                    "ActionWait",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionWait {
        static mut instance: ::protobuf::lazy::Lazy<ActionWait> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionWait::new)
        }
    }
}

impl ::protobuf::Clear for ActionWait {
    fn clear(&mut self) {
        self.ms = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionWait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionWait {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionTextType {
    // message fields
    pub text: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionTextType {
    fn default() -> &'a ActionTextType {
        <ActionTextType as ::protobuf::Message>::default_instance()
    }
}

impl ActionTextType {
    pub fn new() -> ActionTextType {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        ::protobuf::Clear::clear(&mut self.text);
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.text, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ActionTextType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionTextType {
        ActionTextType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "text",
                    |m: &ActionTextType| { &m.text },
                    |m: &mut ActionTextType| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionTextType>(
                    "ActionTextType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionTextType {
        static mut instance: ::protobuf::lazy::Lazy<ActionTextType> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionTextType::new)
        }
    }
}

impl ::protobuf::Clear for ActionTextType {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.text);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionTextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionTextType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionExecuteCode {
    // message fields
    pub code: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionExecuteCode {
    fn default() -> &'a ActionExecuteCode {
        <ActionExecuteCode as ::protobuf::Message>::default_instance()
    }
}

impl ActionExecuteCode {
    pub fn new() -> ActionExecuteCode {
        ::std::default::Default::default()
    }

    // string code = 1;


    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        ::protobuf::Clear::clear(&mut self.code);
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::protobuf::Chars) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::protobuf::Chars {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.code, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ActionExecuteCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionExecuteCode {
        ActionExecuteCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "code",
                    |m: &ActionExecuteCode| { &m.code },
                    |m: &mut ActionExecuteCode| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionExecuteCode>(
                    "ActionExecuteCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionExecuteCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionExecuteCode> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionExecuteCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionExecuteCode {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.code);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionExecuteCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionExecuteCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionExecuteFunction {
    // message fields
    pub function_name: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionExecuteFunction {
    fn default() -> &'a ActionExecuteFunction {
        <ActionExecuteFunction as ::protobuf::Message>::default_instance()
    }
}

impl ActionExecuteFunction {
    pub fn new() -> ActionExecuteFunction {
        ::std::default::Default::default()
    }

    // string function_name = 1;


    pub fn get_function_name(&self) -> &str {
        &self.function_name
    }
    pub fn clear_function_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.function_name);
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: ::protobuf::Chars) {
        self.function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.function_name
    }

    // Take field
    pub fn take_function_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.function_name, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ActionExecuteFunction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.function_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.function_name.is_empty() {
            os.write_string(1, &self.function_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionExecuteFunction {
        ActionExecuteFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "function_name",
                    |m: &ActionExecuteFunction| { &m.function_name },
                    |m: &mut ActionExecuteFunction| { &mut m.function_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionExecuteFunction>(
                    "ActionExecuteFunction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionExecuteFunction {
        static mut instance: ::protobuf::lazy::Lazy<ActionExecuteFunction> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionExecuteFunction::new)
        }
    }
}

impl ::protobuf::Clear for ActionExecuteFunction {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.function_name);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionExecuteFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionExecuteFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionExecuteOSCommand {
    // message fields
    pub os_command: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionExecuteOSCommand {
    fn default() -> &'a ActionExecuteOSCommand {
        <ActionExecuteOSCommand as ::protobuf::Message>::default_instance()
    }
}

impl ActionExecuteOSCommand {
    pub fn new() -> ActionExecuteOSCommand {
        ::std::default::Default::default()
    }

    // string os_command = 1;


    pub fn get_os_command(&self) -> &str {
        &self.os_command
    }
    pub fn clear_os_command(&mut self) {
        ::protobuf::Clear::clear(&mut self.os_command);
    }

    // Param is passed by value, moved
    pub fn set_os_command(&mut self, v: ::protobuf::Chars) {
        self.os_command = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_command(&mut self) -> &mut ::protobuf::Chars {
        &mut self.os_command
    }

    // Take field
    pub fn take_os_command(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.os_command, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ActionExecuteOSCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.os_command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.os_command.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.os_command);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.os_command.is_empty() {
            os.write_string(1, &self.os_command)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionExecuteOSCommand {
        ActionExecuteOSCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "os_command",
                    |m: &ActionExecuteOSCommand| { &m.os_command },
                    |m: &mut ActionExecuteOSCommand| { &mut m.os_command },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionExecuteOSCommand>(
                    "ActionExecuteOSCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionExecuteOSCommand {
        static mut instance: ::protobuf::lazy::Lazy<ActionExecuteOSCommand> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionExecuteOSCommand::new)
        }
    }
}

impl ::protobuf::Clear for ActionExecuteOSCommand {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.os_command);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionExecuteOSCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionExecuteOSCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionExecuteNamedAction {
    // message fields
    pub action_name: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionExecuteNamedAction {
    fn default() -> &'a ActionExecuteNamedAction {
        <ActionExecuteNamedAction as ::protobuf::Message>::default_instance()
    }
}

impl ActionExecuteNamedAction {
    pub fn new() -> ActionExecuteNamedAction {
        ::std::default::Default::default()
    }

    // string action_name = 1;


    pub fn get_action_name(&self) -> &str {
        &self.action_name
    }
    pub fn clear_action_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.action_name);
    }

    // Param is passed by value, moved
    pub fn set_action_name(&mut self, v: ::protobuf::Chars) {
        self.action_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.action_name
    }

    // Take field
    pub fn take_action_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.action_name, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ActionExecuteNamedAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.action_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.action_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.action_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.action_name.is_empty() {
            os.write_string(1, &self.action_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionExecuteNamedAction {
        ActionExecuteNamedAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "action_name",
                    |m: &ActionExecuteNamedAction| { &m.action_name },
                    |m: &mut ActionExecuteNamedAction| { &mut m.action_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionExecuteNamedAction>(
                    "ActionExecuteNamedAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionExecuteNamedAction {
        static mut instance: ::protobuf::lazy::Lazy<ActionExecuteNamedAction> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionExecuteNamedAction::new)
        }
    }
}

impl ::protobuf::Clear for ActionExecuteNamedAction {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.action_name);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionExecuteNamedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionExecuteNamedAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionExecuteInterpreterValue {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionExecuteInterpreterValue {
    fn default() -> &'a ActionExecuteInterpreterValue {
        <ActionExecuteInterpreterValue as ::protobuf::Message>::default_instance()
    }
}

impl ActionExecuteInterpreterValue {
    pub fn new() -> ActionExecuteInterpreterValue {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ActionExecuteInterpreterValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionExecuteInterpreterValue {
        ActionExecuteInterpreterValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionExecuteInterpreterValue>(
                    "ActionExecuteInterpreterValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionExecuteInterpreterValue {
        static mut instance: ::protobuf::lazy::Lazy<ActionExecuteInterpreterValue> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionExecuteInterpreterValue::new)
        }
    }
}

impl ::protobuf::Clear for ActionExecuteInterpreterValue {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionExecuteInterpreterValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionExecuteInterpreterValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action {
    // message oneof groups
    pub action: ::std::option::Option<Action_oneof_action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Action_oneof_action {
    action_key_press(ActionKeyPress),
    action_key_click(ActionKeyClick),
    action_key_release(ActionKeyRelease),
    action_mouse_button_press(ActionMouseButtonPress),
    action_mouse_button_click(ActionMouseButtonClick),
    action_mouse_button_release(ActionMouseButtonRelease),
    action_text_key_click(ActionTextKeyClick),
    action_number_key_click(ActionNumberKeyClick),
    action_function_key_click(ActionFunctionKeyClick),
    action_control_key_click(ActionControlKeyClick),
    action_kp_key_click(ActionKPKeyClick),
    action_multimedia_key_click(ActionMultimediaKeyClick),
    action_mouse_button_key_click(ActionMouseButtonKeyClick),
    action_mouse_relative_move(ActionMouseRelativeMove),
    action_mouse_absolute_move(ActionMouseAbsoluteMove),
    action_text_type(ActionTextType),
    action_wait(ActionWait),
    action_execute_code(ActionExecuteCode),
    action_execute_function(ActionExecuteFunction),
    action_execute_os_command(ActionExecuteOSCommand),
    action_execute_named_action(ActionExecuteNamedAction),
    action_execute_interpreter_value(ActionExecuteInterpreterValue),
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    // .ActionKeyPress action_key_press = 1;


    pub fn get_action_key_press(&self) -> &ActionKeyPress {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_press(ref v)) => v,
            _ => ActionKeyPress::default_instance(),
        }
    }
    pub fn clear_action_key_press(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_key_press(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_press(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_key_press(&mut self, v: ActionKeyPress) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_key_press(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_key_press(&mut self) -> &mut ActionKeyPress {
        if let ::std::option::Option::Some(Action_oneof_action::action_key_press(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_key_press(ActionKeyPress::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_press(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_key_press(&mut self) -> ActionKeyPress {
        if self.has_action_key_press() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_key_press(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionKeyPress::new()
        }
    }

    // .ActionKeyClick action_key_click = 2;


    pub fn get_action_key_click(&self) -> &ActionKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_click(ref v)) => v,
            _ => ActionKeyClick::default_instance(),
        }
    }
    pub fn clear_action_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_key_click(&mut self, v: ActionKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_key_click(&mut self) -> &mut ActionKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_key_click(ActionKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_key_click(&mut self) -> ActionKeyClick {
        if self.has_action_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionKeyClick::new()
        }
    }

    // .ActionKeyRelease action_key_release = 3;


    pub fn get_action_key_release(&self) -> &ActionKeyRelease {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_release(ref v)) => v,
            _ => ActionKeyRelease::default_instance(),
        }
    }
    pub fn clear_action_key_release(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_key_release(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_release(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_key_release(&mut self, v: ActionKeyRelease) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_key_release(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_key_release(&mut self) -> &mut ActionKeyRelease {
        if let ::std::option::Option::Some(Action_oneof_action::action_key_release(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_key_release(ActionKeyRelease::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_key_release(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_key_release(&mut self) -> ActionKeyRelease {
        if self.has_action_key_release() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_key_release(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionKeyRelease::new()
        }
    }

    // .ActionMouseButtonPress action_mouse_button_press = 4;


    pub fn get_action_mouse_button_press(&self) -> &ActionMouseButtonPress {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(ref v)) => v,
            _ => ActionMouseButtonPress::default_instance(),
        }
    }
    pub fn clear_action_mouse_button_press(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_mouse_button_press(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_mouse_button_press(&mut self, v: ActionMouseButtonPress) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_mouse_button_press(&mut self) -> &mut ActionMouseButtonPress {
        if let ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(ActionMouseButtonPress::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_mouse_button_press(&mut self) -> ActionMouseButtonPress {
        if self.has_action_mouse_button_press() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMouseButtonPress::new()
        }
    }

    // .ActionMouseButtonClick action_mouse_button_click = 5;


    pub fn get_action_mouse_button_click(&self) -> &ActionMouseButtonClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(ref v)) => v,
            _ => ActionMouseButtonClick::default_instance(),
        }
    }
    pub fn clear_action_mouse_button_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_mouse_button_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_mouse_button_click(&mut self, v: ActionMouseButtonClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_mouse_button_click(&mut self) -> &mut ActionMouseButtonClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(ActionMouseButtonClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_mouse_button_click(&mut self) -> ActionMouseButtonClick {
        if self.has_action_mouse_button_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMouseButtonClick::new()
        }
    }

    // .ActionMouseButtonRelease action_mouse_button_release = 6;


    pub fn get_action_mouse_button_release(&self) -> &ActionMouseButtonRelease {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(ref v)) => v,
            _ => ActionMouseButtonRelease::default_instance(),
        }
    }
    pub fn clear_action_mouse_button_release(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_mouse_button_release(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_mouse_button_release(&mut self, v: ActionMouseButtonRelease) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_mouse_button_release(&mut self) -> &mut ActionMouseButtonRelease {
        if let ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(ActionMouseButtonRelease::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_mouse_button_release(&mut self) -> ActionMouseButtonRelease {
        if self.has_action_mouse_button_release() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMouseButtonRelease::new()
        }
    }

    // .ActionTextKeyClick action_text_key_click = 7;


    pub fn get_action_text_key_click(&self) -> &ActionTextKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_text_key_click(ref v)) => v,
            _ => ActionTextKeyClick::default_instance(),
        }
    }
    pub fn clear_action_text_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_text_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_text_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_text_key_click(&mut self, v: ActionTextKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_text_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_text_key_click(&mut self) -> &mut ActionTextKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_text_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_text_key_click(ActionTextKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_text_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_text_key_click(&mut self) -> ActionTextKeyClick {
        if self.has_action_text_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_text_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionTextKeyClick::new()
        }
    }

    // .ActionNumberKeyClick action_number_key_click = 8;


    pub fn get_action_number_key_click(&self) -> &ActionNumberKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_number_key_click(ref v)) => v,
            _ => ActionNumberKeyClick::default_instance(),
        }
    }
    pub fn clear_action_number_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_number_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_number_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_number_key_click(&mut self, v: ActionNumberKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_number_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_number_key_click(&mut self) -> &mut ActionNumberKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_number_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_number_key_click(ActionNumberKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_number_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_number_key_click(&mut self) -> ActionNumberKeyClick {
        if self.has_action_number_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_number_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionNumberKeyClick::new()
        }
    }

    // .ActionFunctionKeyClick action_function_key_click = 9;


    pub fn get_action_function_key_click(&self) -> &ActionFunctionKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_function_key_click(ref v)) => v,
            _ => ActionFunctionKeyClick::default_instance(),
        }
    }
    pub fn clear_action_function_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_function_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_function_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_function_key_click(&mut self, v: ActionFunctionKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_function_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_function_key_click(&mut self) -> &mut ActionFunctionKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_function_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_function_key_click(ActionFunctionKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_function_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_function_key_click(&mut self) -> ActionFunctionKeyClick {
        if self.has_action_function_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_function_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionFunctionKeyClick::new()
        }
    }

    // .ActionControlKeyClick action_control_key_click = 10;


    pub fn get_action_control_key_click(&self) -> &ActionControlKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_control_key_click(ref v)) => v,
            _ => ActionControlKeyClick::default_instance(),
        }
    }
    pub fn clear_action_control_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_control_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_control_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_control_key_click(&mut self, v: ActionControlKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_control_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_control_key_click(&mut self) -> &mut ActionControlKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_control_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_control_key_click(ActionControlKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_control_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_control_key_click(&mut self) -> ActionControlKeyClick {
        if self.has_action_control_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_control_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionControlKeyClick::new()
        }
    }

    // .ActionKPKeyClick action_kp_key_click = 11;


    pub fn get_action_kp_key_click(&self) -> &ActionKPKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(ref v)) => v,
            _ => ActionKPKeyClick::default_instance(),
        }
    }
    pub fn clear_action_kp_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_kp_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_kp_key_click(&mut self, v: ActionKPKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_kp_key_click(&mut self) -> &mut ActionKPKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(ActionKPKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_kp_key_click(&mut self) -> ActionKPKeyClick {
        if self.has_action_kp_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionKPKeyClick::new()
        }
    }

    // .ActionMultimediaKeyClick action_multimedia_key_click = 12;


    pub fn get_action_multimedia_key_click(&self) -> &ActionMultimediaKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(ref v)) => v,
            _ => ActionMultimediaKeyClick::default_instance(),
        }
    }
    pub fn clear_action_multimedia_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_multimedia_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_multimedia_key_click(&mut self, v: ActionMultimediaKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_multimedia_key_click(&mut self) -> &mut ActionMultimediaKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(ActionMultimediaKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_multimedia_key_click(&mut self) -> ActionMultimediaKeyClick {
        if self.has_action_multimedia_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMultimediaKeyClick::new()
        }
    }

    // .ActionMouseButtonKeyClick action_mouse_button_key_click = 13;


    pub fn get_action_mouse_button_key_click(&self) -> &ActionMouseButtonKeyClick {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(ref v)) => v,
            _ => ActionMouseButtonKeyClick::default_instance(),
        }
    }
    pub fn clear_action_mouse_button_key_click(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_mouse_button_key_click(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_mouse_button_key_click(&mut self, v: ActionMouseButtonKeyClick) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_mouse_button_key_click(&mut self) -> &mut ActionMouseButtonKeyClick {
        if let ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(ActionMouseButtonKeyClick::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_mouse_button_key_click(&mut self) -> ActionMouseButtonKeyClick {
        if self.has_action_mouse_button_key_click() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMouseButtonKeyClick::new()
        }
    }

    // .ActionMouseRelativeMove action_mouse_relative_move = 14;


    pub fn get_action_mouse_relative_move(&self) -> &ActionMouseRelativeMove {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(ref v)) => v,
            _ => ActionMouseRelativeMove::default_instance(),
        }
    }
    pub fn clear_action_mouse_relative_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_mouse_relative_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_mouse_relative_move(&mut self, v: ActionMouseRelativeMove) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_mouse_relative_move(&mut self) -> &mut ActionMouseRelativeMove {
        if let ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(ActionMouseRelativeMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_mouse_relative_move(&mut self) -> ActionMouseRelativeMove {
        if self.has_action_mouse_relative_move() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMouseRelativeMove::new()
        }
    }

    // .ActionMouseAbsoluteMove action_mouse_absolute_move = 15;


    pub fn get_action_mouse_absolute_move(&self) -> &ActionMouseAbsoluteMove {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(ref v)) => v,
            _ => ActionMouseAbsoluteMove::default_instance(),
        }
    }
    pub fn clear_action_mouse_absolute_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_mouse_absolute_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_mouse_absolute_move(&mut self, v: ActionMouseAbsoluteMove) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_mouse_absolute_move(&mut self) -> &mut ActionMouseAbsoluteMove {
        if let ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(ActionMouseAbsoluteMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_mouse_absolute_move(&mut self) -> ActionMouseAbsoluteMove {
        if self.has_action_mouse_absolute_move() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMouseAbsoluteMove::new()
        }
    }

    // .ActionTextType action_text_type = 16;


    pub fn get_action_text_type(&self) -> &ActionTextType {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_text_type(ref v)) => v,
            _ => ActionTextType::default_instance(),
        }
    }
    pub fn clear_action_text_type(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_text_type(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_text_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_text_type(&mut self, v: ActionTextType) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_text_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_text_type(&mut self) -> &mut ActionTextType {
        if let ::std::option::Option::Some(Action_oneof_action::action_text_type(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_text_type(ActionTextType::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_text_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_text_type(&mut self) -> ActionTextType {
        if self.has_action_text_type() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_text_type(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionTextType::new()
        }
    }

    // .ActionWait action_wait = 17;


    pub fn get_action_wait(&self) -> &ActionWait {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_wait(ref v)) => v,
            _ => ActionWait::default_instance(),
        }
    }
    pub fn clear_action_wait(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_wait(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_wait(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_wait(&mut self, v: ActionWait) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_wait(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_wait(&mut self) -> &mut ActionWait {
        if let ::std::option::Option::Some(Action_oneof_action::action_wait(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_wait(ActionWait::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_wait(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_wait(&mut self) -> ActionWait {
        if self.has_action_wait() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_wait(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionWait::new()
        }
    }

    // .ActionExecuteCode action_execute_code = 18;


    pub fn get_action_execute_code(&self) -> &ActionExecuteCode {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_code(ref v)) => v,
            _ => ActionExecuteCode::default_instance(),
        }
    }
    pub fn clear_action_execute_code(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_execute_code(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_code(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_execute_code(&mut self, v: ActionExecuteCode) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_code(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_execute_code(&mut self) -> &mut ActionExecuteCode {
        if let ::std::option::Option::Some(Action_oneof_action::action_execute_code(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_code(ActionExecuteCode::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_code(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_execute_code(&mut self) -> ActionExecuteCode {
        if self.has_action_execute_code() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_execute_code(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionExecuteCode::new()
        }
    }

    // .ActionExecuteFunction action_execute_function = 19;


    pub fn get_action_execute_function(&self) -> &ActionExecuteFunction {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_function(ref v)) => v,
            _ => ActionExecuteFunction::default_instance(),
        }
    }
    pub fn clear_action_execute_function(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_execute_function(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_execute_function(&mut self, v: ActionExecuteFunction) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_execute_function(&mut self) -> &mut ActionExecuteFunction {
        if let ::std::option::Option::Some(Action_oneof_action::action_execute_function(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_function(ActionExecuteFunction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_execute_function(&mut self) -> ActionExecuteFunction {
        if self.has_action_execute_function() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_execute_function(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionExecuteFunction::new()
        }
    }

    // .ActionExecuteOSCommand action_execute_os_command = 20;


    pub fn get_action_execute_os_command(&self) -> &ActionExecuteOSCommand {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(ref v)) => v,
            _ => ActionExecuteOSCommand::default_instance(),
        }
    }
    pub fn clear_action_execute_os_command(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_execute_os_command(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_execute_os_command(&mut self, v: ActionExecuteOSCommand) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_execute_os_command(&mut self) -> &mut ActionExecuteOSCommand {
        if let ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(ActionExecuteOSCommand::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_execute_os_command(&mut self) -> ActionExecuteOSCommand {
        if self.has_action_execute_os_command() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionExecuteOSCommand::new()
        }
    }

    // .ActionExecuteNamedAction action_execute_named_action = 21;


    pub fn get_action_execute_named_action(&self) -> &ActionExecuteNamedAction {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(ref v)) => v,
            _ => ActionExecuteNamedAction::default_instance(),
        }
    }
    pub fn clear_action_execute_named_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_execute_named_action(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_execute_named_action(&mut self, v: ActionExecuteNamedAction) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_execute_named_action(&mut self) -> &mut ActionExecuteNamedAction {
        if let ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(ActionExecuteNamedAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_execute_named_action(&mut self) -> ActionExecuteNamedAction {
        if self.has_action_execute_named_action() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionExecuteNamedAction::new()
        }
    }

    // .ActionExecuteInterpreterValue action_execute_interpreter_value = 22;


    pub fn get_action_execute_interpreter_value(&self) -> &ActionExecuteInterpreterValue {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(ref v)) => v,
            _ => ActionExecuteInterpreterValue::default_instance(),
        }
    }
    pub fn clear_action_execute_interpreter_value(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action_execute_interpreter_value(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_execute_interpreter_value(&mut self, v: ActionExecuteInterpreterValue) {
        self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_execute_interpreter_value(&mut self) -> &mut ActionExecuteInterpreterValue {
        if let ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(ActionExecuteInterpreterValue::new()));
        }
        match self.action {
            ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_execute_interpreter_value(&mut self) -> ActionExecuteInterpreterValue {
        if self.has_action_execute_interpreter_value() {
            match self.action.take() {
                ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionExecuteInterpreterValue::new()
        }
    }
}

impl ::protobuf::Message for Action {
    fn is_initialized(&self) -> bool {
        if let Some(Action_oneof_action::action_key_press(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_key_release(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_mouse_button_press(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_mouse_button_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_mouse_button_release(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_text_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_number_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_function_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_control_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_kp_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_multimedia_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_mouse_button_key_click(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_mouse_relative_move(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_mouse_absolute_move(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_text_type(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_wait(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_execute_code(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_execute_function(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_execute_os_command(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_execute_named_action(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Action_oneof_action::action_execute_interpreter_value(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_key_press(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_key_click(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_key_release(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_press(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_click(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_release(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_text_key_click(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_number_key_click(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_function_key_click(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_control_key_click(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_kp_key_click(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_multimedia_key_click(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_button_key_click(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_relative_move(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_mouse_absolute_move(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_text_type(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_wait(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_code(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_function(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_os_command(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_named_action(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Action_oneof_action::action_execute_interpreter_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Action_oneof_action::action_key_press(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_key_release(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_mouse_button_press(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_mouse_button_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_mouse_button_release(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_text_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_number_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_function_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_control_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_kp_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_multimedia_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_mouse_button_key_click(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_mouse_relative_move(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_mouse_absolute_move(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_text_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_wait(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_execute_code(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_execute_function(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_execute_os_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_execute_named_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Action_oneof_action::action_execute_interpreter_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Action_oneof_action::action_key_press(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_key_click(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_key_release(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_mouse_button_press(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_mouse_button_click(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_mouse_button_release(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_text_key_click(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_number_key_click(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_function_key_click(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_control_key_click(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_kp_key_click(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_multimedia_key_click(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_mouse_button_key_click(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_mouse_relative_move(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_mouse_absolute_move(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_text_type(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_wait(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_execute_code(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_execute_function(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_execute_os_command(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_execute_named_action(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Action_oneof_action::action_execute_interpreter_value(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action {
        Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionKeyPress>(
                    "action_key_press",
                    Action::has_action_key_press,
                    Action::get_action_key_press,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionKeyClick>(
                    "action_key_click",
                    Action::has_action_key_click,
                    Action::get_action_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionKeyRelease>(
                    "action_key_release",
                    Action::has_action_key_release,
                    Action::get_action_key_release,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMouseButtonPress>(
                    "action_mouse_button_press",
                    Action::has_action_mouse_button_press,
                    Action::get_action_mouse_button_press,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMouseButtonClick>(
                    "action_mouse_button_click",
                    Action::has_action_mouse_button_click,
                    Action::get_action_mouse_button_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMouseButtonRelease>(
                    "action_mouse_button_release",
                    Action::has_action_mouse_button_release,
                    Action::get_action_mouse_button_release,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionTextKeyClick>(
                    "action_text_key_click",
                    Action::has_action_text_key_click,
                    Action::get_action_text_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionNumberKeyClick>(
                    "action_number_key_click",
                    Action::has_action_number_key_click,
                    Action::get_action_number_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionFunctionKeyClick>(
                    "action_function_key_click",
                    Action::has_action_function_key_click,
                    Action::get_action_function_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionControlKeyClick>(
                    "action_control_key_click",
                    Action::has_action_control_key_click,
                    Action::get_action_control_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionKPKeyClick>(
                    "action_kp_key_click",
                    Action::has_action_kp_key_click,
                    Action::get_action_kp_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMultimediaKeyClick>(
                    "action_multimedia_key_click",
                    Action::has_action_multimedia_key_click,
                    Action::get_action_multimedia_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMouseButtonKeyClick>(
                    "action_mouse_button_key_click",
                    Action::has_action_mouse_button_key_click,
                    Action::get_action_mouse_button_key_click,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMouseRelativeMove>(
                    "action_mouse_relative_move",
                    Action::has_action_mouse_relative_move,
                    Action::get_action_mouse_relative_move,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMouseAbsoluteMove>(
                    "action_mouse_absolute_move",
                    Action::has_action_mouse_absolute_move,
                    Action::get_action_mouse_absolute_move,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionTextType>(
                    "action_text_type",
                    Action::has_action_text_type,
                    Action::get_action_text_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionWait>(
                    "action_wait",
                    Action::has_action_wait,
                    Action::get_action_wait,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionExecuteCode>(
                    "action_execute_code",
                    Action::has_action_execute_code,
                    Action::get_action_execute_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionExecuteFunction>(
                    "action_execute_function",
                    Action::has_action_execute_function,
                    Action::get_action_execute_function,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionExecuteOSCommand>(
                    "action_execute_os_command",
                    Action::has_action_execute_os_command,
                    Action::get_action_execute_os_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionExecuteNamedAction>(
                    "action_execute_named_action",
                    Action::has_action_execute_named_action,
                    Action::get_action_execute_named_action,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionExecuteInterpreterValue>(
                    "action_execute_interpreter_value",
                    Action::has_action_execute_interpreter_value,
                    Action::get_action_execute_interpreter_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Action>(
                    "Action",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Action {
        static mut instance: ::protobuf::lazy::Lazy<Action> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Action::new)
        }
    }
}

impl ::protobuf::Clear for Action {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamedAction {
    // message fields
    pub action_name: ::protobuf::Chars,
    pub action: ::protobuf::SingularPtrField<Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamedAction {
    fn default() -> &'a NamedAction {
        <NamedAction as ::protobuf::Message>::default_instance()
    }
}

impl NamedAction {
    pub fn new() -> NamedAction {
        ::std::default::Default::default()
    }

    // string action_name = 1;


    pub fn get_action_name(&self) -> &str {
        &self.action_name
    }
    pub fn clear_action_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.action_name);
    }

    // Param is passed by value, moved
    pub fn set_action_name(&mut self, v: ::protobuf::Chars) {
        self.action_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.action_name
    }

    // Take field
    pub fn take_action_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.action_name, ::protobuf::Chars::new())
    }

    // .Action action = 2;


    pub fn get_action(&self) -> &Action {
        self.action.as_ref().unwrap_or_else(|| Action::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> Action {
        self.action.take().unwrap_or_else(|| Action::new())
    }
}

impl ::protobuf::Message for NamedAction {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.action_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.action_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.action_name);
        }
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.action_name.is_empty() {
            os.write_string(1, &self.action_name)?;
        }
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamedAction {
        NamedAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "action_name",
                    |m: &NamedAction| { &m.action_name },
                    |m: &mut NamedAction| { &mut m.action_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                    "action",
                    |m: &NamedAction| { &m.action },
                    |m: &mut NamedAction| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamedAction>(
                    "NamedAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NamedAction {
        static mut instance: ::protobuf::lazy::Lazy<NamedAction> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NamedAction::new)
        }
    }
}

impl ::protobuf::Clear for NamedAction {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.action_name);
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionList {
    // message fields
    pub actions: ::protobuf::RepeatedField<Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionList {
    fn default() -> &'a ActionList {
        <ActionList as ::protobuf::Message>::default_instance()
    }
}

impl ActionList {
    pub fn new() -> ActionList {
        ::std::default::Default::default()
    }

    // repeated .Action actions = 1;


    pub fn get_actions(&self) -> &[Action] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<Action>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<Action> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<Action> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ActionList {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionList {
        ActionList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                    "actions",
                    |m: &ActionList| { &m.actions },
                    |m: &mut ActionList| { &mut m.actions },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionList>(
                    "ActionList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionList {
        static mut instance: ::protobuf::lazy::Lazy<ActionList> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ActionList::new)
        }
    }
}

impl ::protobuf::Clear for ActionList {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key1 {
    // message fields
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key1 {
    fn default() -> &'a Key1 {
        <Key1 as ::protobuf::Message>::default_instance()
    }
}

impl Key1 {
    pub fn new() -> Key1 {
        ::std::default::Default::default()
    }

    // int32 key_code = 1;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for Key1 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_code != 0 {
            os.write_int32(1, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key1 {
        Key1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &Key1| { &m.key_code },
                    |m: &mut Key1| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key1>(
                    "Key1",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key1 {
        static mut instance: ::protobuf::lazy::Lazy<Key1> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Key1::new)
        }
    }
}

impl ::protobuf::Clear for Key1 {
    fn clear(&mut self) {
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key2 {
    // message fields
    pub device_id: i32,
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key2 {
    fn default() -> &'a Key2 {
        <Key2 as ::protobuf::Message>::default_instance()
    }
}

impl Key2 {
    pub fn new() -> Key2 {
        ::std::default::Default::default()
    }

    // int32 device_id = 1;


    pub fn get_device_id(&self) -> i32 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: i32) {
        self.device_id = v;
    }

    // int32 key_code = 2;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for Key2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(2, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_int32(1, self.device_id)?;
        }
        if self.key_code != 0 {
            os.write_int32(2, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key2 {
        Key2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_id",
                    |m: &Key2| { &m.device_id },
                    |m: &mut Key2| { &mut m.device_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &Key2| { &m.key_code },
                    |m: &mut Key2| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key2>(
                    "Key2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key2 {
        static mut instance: ::protobuf::lazy::Lazy<Key2> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Key2::new)
        }
    }
}

impl ::protobuf::Clear for Key2 {
    fn clear(&mut self) {
        self.device_id = 0;
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message oneof groups
    pub key: ::std::option::Option<Key_oneof_key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Key_oneof_key {
    key_1(Key1),
    key_2(Key2),
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // .Key1 key_1 = 1;


    pub fn get_key_1(&self) -> &Key1 {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::key_1(ref v)) => v,
            _ => Key1::default_instance(),
        }
    }
    pub fn clear_key_1(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key_1(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::key_1(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_1(&mut self, v: Key1) {
        self.key = ::std::option::Option::Some(Key_oneof_key::key_1(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_1(&mut self) -> &mut Key1 {
        if let ::std::option::Option::Some(Key_oneof_key::key_1(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::key_1(Key1::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::key_1(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_1(&mut self) -> Key1 {
        if self.has_key_1() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::key_1(v)) => v,
                _ => panic!(),
            }
        } else {
            Key1::new()
        }
    }

    // .Key2 key_2 = 2;


    pub fn get_key_2(&self) -> &Key2 {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::key_2(ref v)) => v,
            _ => Key2::default_instance(),
        }
    }
    pub fn clear_key_2(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key_2(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::key_2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_2(&mut self, v: Key2) {
        self.key = ::std::option::Option::Some(Key_oneof_key::key_2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_2(&mut self) -> &mut Key2 {
        if let ::std::option::Option::Some(Key_oneof_key::key_2(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::key_2(Key2::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::key_2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_2(&mut self) -> Key2 {
        if self.has_key_2() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::key_2(v)) => v,
                _ => panic!(),
            }
        } else {
            Key2::new()
        }
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        if let Some(Key_oneof_key::key_1(ref v)) = self.key {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Key_oneof_key::key_2(ref v)) = self.key {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::key_1(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::key_2(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.key {
            match v {
                &Key_oneof_key::key_1(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Key_oneof_key::key_2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.key {
            match v {
                &Key_oneof_key::key_1(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Key_oneof_key::key_2(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Key1>(
                    "key_1",
                    Key::has_key_1,
                    Key::get_key_1,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Key2>(
                    "key_2",
                    Key::has_key_2,
                    Key::get_key_2,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key>(
                    "Key",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key {
        static mut instance: ::protobuf::lazy::Lazy<Key> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Key::new)
        }
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifierDescription {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    pub alias: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifierDescription {
    fn default() -> &'a ModifierDescription {
        <ModifierDescription as ::protobuf::Message>::default_instance()
    }
}

impl ModifierDescription {
    pub fn new() -> ModifierDescription {
        ::std::default::Default::default()
    }

    // .Key key = 1;


    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }

    // string alias = 2;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        ::protobuf::Clear::clear(&mut self.alias);
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::protobuf::Chars) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::protobuf::Chars {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.alias, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ModifierDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.alias)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.alias);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.alias.is_empty() {
            os.write_string(2, &self.alias)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifierDescription {
        ModifierDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "key",
                    |m: &ModifierDescription| { &m.key },
                    |m: &mut ModifierDescription| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "alias",
                    |m: &ModifierDescription| { &m.alias },
                    |m: &mut ModifierDescription| { &mut m.alias },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifierDescription>(
                    "ModifierDescription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifierDescription {
        static mut instance: ::protobuf::lazy::Lazy<ModifierDescription> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ModifierDescription::new)
        }
    }
}

impl ::protobuf::Clear for ModifierDescription {
    fn clear(&mut self) {
        self.key.clear();
        ::protobuf::Clear::clear(&mut self.alias);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifierDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifierDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyChord {
    // message fields
    pub modifiers: ::protobuf::RepeatedField<Key>,
    pub ordinary_key: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyChord {
    fn default() -> &'a KeyChord {
        <KeyChord as ::protobuf::Message>::default_instance()
    }
}

impl KeyChord {
    pub fn new() -> KeyChord {
        ::std::default::Default::default()
    }

    // repeated .Key modifiers = 1;


    pub fn get_modifiers(&self) -> &[Key] {
        &self.modifiers
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifiers(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.modifiers
    }

    // Take field
    pub fn take_modifiers(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.modifiers, ::protobuf::RepeatedField::new())
    }

    // .Key ordinary_key = 2;


    pub fn get_ordinary_key(&self) -> &Key {
        self.ordinary_key.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_ordinary_key(&mut self) {
        self.ordinary_key.clear();
    }

    pub fn has_ordinary_key(&self) -> bool {
        self.ordinary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinary_key(&mut self, v: Key) {
        self.ordinary_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordinary_key(&mut self) -> &mut Key {
        if self.ordinary_key.is_none() {
            self.ordinary_key.set_default();
        }
        self.ordinary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_ordinary_key(&mut self) -> Key {
        self.ordinary_key.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for KeyChord {
    fn is_initialized(&self) -> bool {
        for v in &self.modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ordinary_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifiers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ordinary_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.ordinary_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.modifiers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.ordinary_key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyChord {
        KeyChord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "modifiers",
                    |m: &KeyChord| { &m.modifiers },
                    |m: &mut KeyChord| { &mut m.modifiers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "ordinary_key",
                    |m: &KeyChord| { &m.ordinary_key },
                    |m: &mut KeyChord| { &mut m.ordinary_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyChord>(
                    "KeyChord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyChord {
        static mut instance: ::protobuf::lazy::Lazy<KeyChord> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyChord::new)
        }
    }
}

impl ::protobuf::Clear for KeyChord {
    fn clear(&mut self) {
        self.modifiers.clear();
        self.ordinary_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyChord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyChord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mapping {
    // message fields
    pub key_chords: ::protobuf::RepeatedField<KeyChord>,
    pub action: ::protobuf::SingularPtrField<Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mapping {
    fn default() -> &'a Mapping {
        <Mapping as ::protobuf::Message>::default_instance()
    }
}

impl Mapping {
    pub fn new() -> Mapping {
        ::std::default::Default::default()
    }

    // repeated .KeyChord key_chords = 1;


    pub fn get_key_chords(&self) -> &[KeyChord] {
        &self.key_chords
    }
    pub fn clear_key_chords(&mut self) {
        self.key_chords.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_chords(&mut self, v: ::protobuf::RepeatedField<KeyChord>) {
        self.key_chords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_chords(&mut self) -> &mut ::protobuf::RepeatedField<KeyChord> {
        &mut self.key_chords
    }

    // Take field
    pub fn take_key_chords(&mut self) -> ::protobuf::RepeatedField<KeyChord> {
        ::std::mem::replace(&mut self.key_chords, ::protobuf::RepeatedField::new())
    }

    // .Action action = 2;


    pub fn get_action(&self) -> &Action {
        self.action.as_ref().unwrap_or_else(|| Action::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> Action {
        self.action.take().unwrap_or_else(|| Action::new())
    }
}

impl ::protobuf::Message for Mapping {
    fn is_initialized(&self) -> bool {
        for v in &self.key_chords {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.key_chords)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.key_chords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.key_chords {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mapping {
        Mapping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyChord>>(
                    "key_chords",
                    |m: &Mapping| { &m.key_chords },
                    |m: &mut Mapping| { &mut m.key_chords },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                    "action",
                    |m: &Mapping| { &m.action },
                    |m: &mut Mapping| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mapping>(
                    "Mapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Mapping {
        static mut instance: ::protobuf::lazy::Lazy<Mapping> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Mapping::new)
        }
    }
}

impl ::protobuf::Clear for Mapping {
    fn clear(&mut self) {
        self.key_chords.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mapping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyDescription {
    // message fields
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
    pub key_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyDescription {
    fn default() -> &'a KeyDescription {
        <KeyDescription as ::protobuf::Message>::default_instance()
    }
}

impl KeyDescription {
    pub fn new() -> KeyDescription {
        ::std::default::Default::default()
    }

    // int32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = v;
    }

    // int32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = v;
    }

    // int32 width = 3;


    pub fn get_width(&self) -> i32 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = v;
    }

    // int32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // int32 key_code = 5;


    pub fn get_key_code(&self) -> i32 {
        self.key_code
    }
    pub fn clear_key_code(&mut self) {
        self.key_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_code(&mut self, v: i32) {
        self.key_code = v;
    }
}

impl ::protobuf::Message for KeyDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_size(1, self.x, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_size(2, self.y, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(3, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_code != 0 {
            my_size += ::protobuf::rt::value_size(5, self.key_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(4, self.height)?;
        }
        if self.key_code != 0 {
            os.write_int32(5, self.key_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyDescription {
        KeyDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &KeyDescription| { &m.x },
                    |m: &mut KeyDescription| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &KeyDescription| { &m.y },
                    |m: &mut KeyDescription| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &KeyDescription| { &m.width },
                    |m: &mut KeyDescription| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &KeyDescription| { &m.height },
                    |m: &mut KeyDescription| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key_code",
                    |m: &KeyDescription| { &m.key_code },
                    |m: &mut KeyDescription| { &mut m.key_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyDescription>(
                    "KeyDescription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyDescription {
        static mut instance: ::protobuf::lazy::Lazy<KeyDescription> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(KeyDescription::new)
        }
    }
}

impl ::protobuf::Clear for KeyDescription {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.key_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceModel {
    // message fields
    pub key_descriptions: ::protobuf::RepeatedField<KeyDescription>,
    pub device_width: i32,
    pub device_height: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceModel {
    fn default() -> &'a DeviceModel {
        <DeviceModel as ::protobuf::Message>::default_instance()
    }
}

impl DeviceModel {
    pub fn new() -> DeviceModel {
        ::std::default::Default::default()
    }

    // repeated .KeyDescription key_descriptions = 1;


    pub fn get_key_descriptions(&self) -> &[KeyDescription] {
        &self.key_descriptions
    }
    pub fn clear_key_descriptions(&mut self) {
        self.key_descriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_descriptions(&mut self, v: ::protobuf::RepeatedField<KeyDescription>) {
        self.key_descriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_descriptions(&mut self) -> &mut ::protobuf::RepeatedField<KeyDescription> {
        &mut self.key_descriptions
    }

    // Take field
    pub fn take_key_descriptions(&mut self) -> ::protobuf::RepeatedField<KeyDescription> {
        ::std::mem::replace(&mut self.key_descriptions, ::protobuf::RepeatedField::new())
    }

    // int32 device_width = 2;


    pub fn get_device_width(&self) -> i32 {
        self.device_width
    }
    pub fn clear_device_width(&mut self) {
        self.device_width = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_width(&mut self, v: i32) {
        self.device_width = v;
    }

    // int32 device_height = 3;


    pub fn get_device_height(&self) -> i32 {
        self.device_height
    }
    pub fn clear_device_height(&mut self) {
        self.device_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_height(&mut self, v: i32) {
        self.device_height = v;
    }
}

impl ::protobuf::Message for DeviceModel {
    fn is_initialized(&self) -> bool {
        for v in &self.key_descriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.key_descriptions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_width = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.key_descriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.device_width != 0 {
            my_size += ::protobuf::rt::value_size(2, self.device_width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.device_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.key_descriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.device_width != 0 {
            os.write_int32(2, self.device_width)?;
        }
        if self.device_height != 0 {
            os.write_int32(3, self.device_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceModel {
        DeviceModel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyDescription>>(
                    "key_descriptions",
                    |m: &DeviceModel| { &m.key_descriptions },
                    |m: &mut DeviceModel| { &mut m.key_descriptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_width",
                    |m: &DeviceModel| { &m.device_width },
                    |m: &mut DeviceModel| { &mut m.device_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_height",
                    |m: &DeviceModel| { &m.device_height },
                    |m: &mut DeviceModel| { &mut m.device_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceModel>(
                    "DeviceModel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceModel {
        static mut instance: ::protobuf::lazy::Lazy<DeviceModel> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeviceModel::new)
        }
    }
}

impl ::protobuf::Clear for DeviceModel {
    fn clear(&mut self) {
        self.key_descriptions.clear();
        self.device_width = 0;
        self.device_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceModel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceInfo {
    // message fields
    pub device_id: i32,
    pub defined: bool,
    pub device_path: ::protobuf::Chars,
    pub device_name: ::protobuf::Chars,
    pub device_model: ::protobuf::SingularPtrField<DeviceModel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceInfo {
    fn default() -> &'a DeviceInfo {
        <DeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfo {
    pub fn new() -> DeviceInfo {
        ::std::default::Default::default()
    }

    // int32 device_id = 1;


    pub fn get_device_id(&self) -> i32 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: i32) {
        self.device_id = v;
    }

    // bool defined = 2;


    pub fn get_defined(&self) -> bool {
        self.defined
    }
    pub fn clear_defined(&mut self) {
        self.defined = false;
    }

    // Param is passed by value, moved
    pub fn set_defined(&mut self, v: bool) {
        self.defined = v;
    }

    // string device_path = 3;


    pub fn get_device_path(&self) -> &str {
        &self.device_path
    }
    pub fn clear_device_path(&mut self) {
        ::protobuf::Clear::clear(&mut self.device_path);
    }

    // Param is passed by value, moved
    pub fn set_device_path(&mut self, v: ::protobuf::Chars) {
        self.device_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_path(&mut self) -> &mut ::protobuf::Chars {
        &mut self.device_path
    }

    // Take field
    pub fn take_device_path(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.device_path, ::protobuf::Chars::new())
    }

    // string device_name = 4;


    pub fn get_device_name(&self) -> &str {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.device_name);
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::protobuf::Chars) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.device_name, ::protobuf::Chars::new())
    }

    // .DeviceModel device_model = 5;


    pub fn get_device_model(&self) -> &DeviceModel {
        self.device_model.as_ref().unwrap_or_else(|| DeviceModel::default_instance())
    }
    pub fn clear_device_model(&mut self) {
        self.device_model.clear();
    }

    pub fn has_device_model(&self) -> bool {
        self.device_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_model(&mut self, v: DeviceModel) {
        self.device_model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_model(&mut self) -> &mut DeviceModel {
        if self.device_model.is_none() {
            self.device_model.set_default();
        }
        self.device_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_model(&mut self) -> DeviceModel {
        self.device_model.take().unwrap_or_else(|| DeviceModel::new())
    }
}

impl ::protobuf::Message for DeviceInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.device_model {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.defined = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.device_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.device_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.defined != false {
            my_size += 2;
        }
        if !self.device_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_path);
        }
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.device_name);
        }
        if let Some(ref v) = self.device_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_int32(1, self.device_id)?;
        }
        if self.defined != false {
            os.write_bool(2, self.defined)?;
        }
        if !self.device_path.is_empty() {
            os.write_string(3, &self.device_path)?;
        }
        if !self.device_name.is_empty() {
            os.write_string(4, &self.device_name)?;
        }
        if let Some(ref v) = self.device_model.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceInfo {
        DeviceInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_id",
                    |m: &DeviceInfo| { &m.device_id },
                    |m: &mut DeviceInfo| { &mut m.device_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "defined",
                    |m: &DeviceInfo| { &m.defined },
                    |m: &mut DeviceInfo| { &mut m.defined },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "device_path",
                    |m: &DeviceInfo| { &m.device_path },
                    |m: &mut DeviceInfo| { &mut m.device_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "device_name",
                    |m: &DeviceInfo| { &m.device_name },
                    |m: &mut DeviceInfo| { &mut m.device_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceModel>>(
                    "device_model",
                    |m: &DeviceInfo| { &m.device_model },
                    |m: &mut DeviceInfo| { &mut m.device_model },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceInfo>(
                    "DeviceInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceInfo {
        static mut instance: ::protobuf::lazy::Lazy<DeviceInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeviceInfo::new)
        }
    }
}

impl ::protobuf::Clear for DeviceInfo {
    fn clear(&mut self) {
        self.device_id = 0;
        self.defined = false;
        ::protobuf::Clear::clear(&mut self.device_path);
        ::protobuf::Clear::clear(&mut self.device_name);
        self.device_model.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeRequest {
    fn default() -> &'a HandshakeRequest {
        <HandshakeRequest as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeRequest {
    pub fn new() -> HandshakeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HandshakeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeRequest {
        HandshakeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeRequest>(
                    "HandshakeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeRequest {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeRequest::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse {
    // message oneof groups
    pub result: ::std::option::Option<HandshakeResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse {
    fn default() -> &'a HandshakeResponse {
        <HandshakeResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HandshakeResponse_oneof_result {
    success_result(HandshakeResponse_SuccessResult),
    error_result(HandshakeResponse_ErrorResult),
    failure_result(HandshakeResponse_FailureResult),
}

impl HandshakeResponse {
    pub fn new() -> HandshakeResponse {
        ::std::default::Default::default()
    }

    // .HandshakeResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &HandshakeResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(ref v)) => v,
            _ => HandshakeResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: HandshakeResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut HandshakeResponse_SuccessResult {
        if let ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(HandshakeResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> HandshakeResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse_SuccessResult::new()
        }
    }

    // .HandshakeResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &HandshakeResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(ref v)) => v,
            _ => HandshakeResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: HandshakeResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut HandshakeResponse_ErrorResult {
        if let ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(HandshakeResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> HandshakeResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse_ErrorResult::new()
        }
    }

    // .HandshakeResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &HandshakeResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(ref v)) => v,
            _ => HandshakeResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: HandshakeResponse_FailureResult) {
        self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut HandshakeResponse_FailureResult {
        if let ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(HandshakeResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> HandshakeResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for HandshakeResponse {
    fn is_initialized(&self) -> bool {
        if let Some(HandshakeResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HandshakeResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HandshakeResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(HandshakeResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &HandshakeResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HandshakeResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HandshakeResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &HandshakeResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HandshakeResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HandshakeResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse {
        HandshakeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse_SuccessResult>(
                    "success_result",
                    HandshakeResponse::has_success_result,
                    HandshakeResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse_ErrorResult>(
                    "error_result",
                    HandshakeResponse::has_error_result,
                    HandshakeResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse_FailureResult>(
                    "failure_result",
                    HandshakeResponse::has_failure_result,
                    HandshakeResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse>(
                    "HandshakeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse_SuccessResult {
    // message fields
    pub version: ::protobuf::Chars,
    pub info: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse_SuccessResult {
    fn default() -> &'a HandshakeResponse_SuccessResult {
        <HandshakeResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse_SuccessResult {
    pub fn new() -> HandshakeResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        ::protobuf::Clear::clear(&mut self.version);
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::protobuf::Chars) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::protobuf::Chars {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.version, ::protobuf::Chars::new())
    }

    // string info = 2;


    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        ::protobuf::Clear::clear(&mut self.info);
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::protobuf::Chars) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::protobuf::Chars {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.info, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for HandshakeResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.info.is_empty() {
            os.write_string(2, &self.info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse_SuccessResult {
        HandshakeResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "version",
                    |m: &HandshakeResponse_SuccessResult| { &m.version },
                    |m: &mut HandshakeResponse_SuccessResult| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "info",
                    |m: &HandshakeResponse_SuccessResult| { &m.info },
                    |m: &mut HandshakeResponse_SuccessResult| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse_SuccessResult>(
                    "HandshakeResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.version);
        ::protobuf::Clear::clear(&mut self.info);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse_ErrorResult {
    fn default() -> &'a HandshakeResponse_ErrorResult {
        <HandshakeResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse_ErrorResult {
    pub fn new() -> HandshakeResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for HandshakeResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse_ErrorResult {
        HandshakeResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &HandshakeResponse_ErrorResult| { &m.message },
                    |m: &mut HandshakeResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse_ErrorResult>(
                    "HandshakeResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse_FailureResult {
    fn default() -> &'a HandshakeResponse_FailureResult {
        <HandshakeResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse_FailureResult {
    pub fn new() -> HandshakeResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for HandshakeResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeResponse_FailureResult {
        HandshakeResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &HandshakeResponse_FailureResult| { &m.message },
                    |m: &mut HandshakeResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeResponse_FailureResult>(
                    "HandshakeResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandshakeResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<HandshakeResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HandshakeResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for HandshakeResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesRequest {
    fn default() -> &'a GetDevicesRequest {
        <GetDevicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesRequest {
    pub fn new() -> GetDevicesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDevicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesRequest {
        GetDevicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesRequest>(
                    "GetDevicesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse {
    // message oneof groups
    pub result: ::std::option::Option<GetDevicesResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse {
    fn default() -> &'a GetDevicesResponse {
        <GetDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetDevicesResponse_oneof_result {
    success_result(GetDevicesResponse_SuccessResult),
    error_result(GetDevicesResponse_ErrorResult),
    failure_result(GetDevicesResponse_FailureResult),
}

impl GetDevicesResponse {
    pub fn new() -> GetDevicesResponse {
        ::std::default::Default::default()
    }

    // .GetDevicesResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &GetDevicesResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(ref v)) => v,
            _ => GetDevicesResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: GetDevicesResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut GetDevicesResponse_SuccessResult {
        if let ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(GetDevicesResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> GetDevicesResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse_SuccessResult::new()
        }
    }

    // .GetDevicesResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &GetDevicesResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(ref v)) => v,
            _ => GetDevicesResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: GetDevicesResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut GetDevicesResponse_ErrorResult {
        if let ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(GetDevicesResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> GetDevicesResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse_ErrorResult::new()
        }
    }

    // .GetDevicesResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &GetDevicesResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(ref v)) => v,
            _ => GetDevicesResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: GetDevicesResponse_FailureResult) {
        self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut GetDevicesResponse_FailureResult {
        if let ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(GetDevicesResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> GetDevicesResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for GetDevicesResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetDevicesResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDevicesResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDevicesResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDevicesResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDevicesResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDevicesResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDevicesResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDevicesResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDevicesResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDevicesResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse {
        GetDevicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse_SuccessResult>(
                    "success_result",
                    GetDevicesResponse::has_success_result,
                    GetDevicesResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse_ErrorResult>(
                    "error_result",
                    GetDevicesResponse::has_error_result,
                    GetDevicesResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse_FailureResult>(
                    "failure_result",
                    GetDevicesResponse::has_failure_result,
                    GetDevicesResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse>(
                    "GetDevicesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse_SuccessResult {
    // message fields
    pub devices_info: ::protobuf::RepeatedField<DeviceInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse_SuccessResult {
    fn default() -> &'a GetDevicesResponse_SuccessResult {
        <GetDevicesResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesResponse_SuccessResult {
    pub fn new() -> GetDevicesResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // repeated .DeviceInfo devices_info = 1;


    pub fn get_devices_info(&self) -> &[DeviceInfo] {
        &self.devices_info
    }
    pub fn clear_devices_info(&mut self) {
        self.devices_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices_info(&mut self, v: ::protobuf::RepeatedField<DeviceInfo>) {
        self.devices_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices_info(&mut self) -> &mut ::protobuf::RepeatedField<DeviceInfo> {
        &mut self.devices_info
    }

    // Take field
    pub fn take_devices_info(&mut self) -> ::protobuf::RepeatedField<DeviceInfo> {
        ::std::mem::replace(&mut self.devices_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDevicesResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        for v in &self.devices_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.devices_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.devices_info {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse_SuccessResult {
        GetDevicesResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceInfo>>(
                    "devices_info",
                    |m: &GetDevicesResponse_SuccessResult| { &m.devices_info },
                    |m: &mut GetDevicesResponse_SuccessResult| { &mut m.devices_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse_SuccessResult>(
                    "GetDevicesResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse_SuccessResult {
    fn clear(&mut self) {
        self.devices_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse_ErrorResult {
    fn default() -> &'a GetDevicesResponse_ErrorResult {
        <GetDevicesResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesResponse_ErrorResult {
    pub fn new() -> GetDevicesResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDevicesResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse_ErrorResult {
        GetDevicesResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDevicesResponse_ErrorResult| { &m.message },
                    |m: &mut GetDevicesResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse_ErrorResult>(
                    "GetDevicesResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDevicesResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDevicesResponse_FailureResult {
    fn default() -> &'a GetDevicesResponse_FailureResult {
        <GetDevicesResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDevicesResponse_FailureResult {
    pub fn new() -> GetDevicesResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDevicesResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDevicesResponse_FailureResult {
        GetDevicesResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDevicesResponse_FailureResult| { &m.message },
                    |m: &mut GetDevicesResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDevicesResponse_FailureResult>(
                    "GetDevicesResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDevicesResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDevicesResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDevicesResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDevicesResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDevicesResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDevicesResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeRequest {
    // message fields
    pub code: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeRequest {
    fn default() -> &'a ExecuteCodeRequest {
        <ExecuteCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeRequest {
    pub fn new() -> ExecuteCodeRequest {
        ::std::default::Default::default()
    }

    // string code = 1;


    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        ::protobuf::Clear::clear(&mut self.code);
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::protobuf::Chars) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::protobuf::Chars {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.code, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeRequest {
        ExecuteCodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "code",
                    |m: &ExecuteCodeRequest| { &m.code },
                    |m: &mut ExecuteCodeRequest| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeRequest>(
                    "ExecuteCodeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeRequest {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.code);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse {
    // message oneof groups
    pub result: ::std::option::Option<ExecuteCodeResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse {
    fn default() -> &'a ExecuteCodeResponse {
        <ExecuteCodeResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExecuteCodeResponse_oneof_result {
    success_result(ExecuteCodeResponse_SuccessResult),
    error_result(ExecuteCodeResponse_ErrorResult),
    failure_result(ExecuteCodeResponse_FailureResult),
}

impl ExecuteCodeResponse {
    pub fn new() -> ExecuteCodeResponse {
        ::std::default::Default::default()
    }

    // .ExecuteCodeResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &ExecuteCodeResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(ref v)) => v,
            _ => ExecuteCodeResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: ExecuteCodeResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut ExecuteCodeResponse_SuccessResult {
        if let ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(ExecuteCodeResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> ExecuteCodeResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse_SuccessResult::new()
        }
    }

    // .ExecuteCodeResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &ExecuteCodeResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(ref v)) => v,
            _ => ExecuteCodeResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: ExecuteCodeResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut ExecuteCodeResponse_ErrorResult {
        if let ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(ExecuteCodeResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> ExecuteCodeResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse_ErrorResult::new()
        }
    }

    // .ExecuteCodeResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &ExecuteCodeResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(ref v)) => v,
            _ => ExecuteCodeResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: ExecuteCodeResponse_FailureResult) {
        self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut ExecuteCodeResponse_FailureResult {
        if let ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(ExecuteCodeResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> ExecuteCodeResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for ExecuteCodeResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ExecuteCodeResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExecuteCodeResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExecuteCodeResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ExecuteCodeResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &ExecuteCodeResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExecuteCodeResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExecuteCodeResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &ExecuteCodeResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExecuteCodeResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExecuteCodeResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse {
        ExecuteCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse_SuccessResult>(
                    "success_result",
                    ExecuteCodeResponse::has_success_result,
                    ExecuteCodeResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse_ErrorResult>(
                    "error_result",
                    ExecuteCodeResponse::has_error_result,
                    ExecuteCodeResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse_FailureResult>(
                    "failure_result",
                    ExecuteCodeResponse::has_failure_result,
                    ExecuteCodeResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse>(
                    "ExecuteCodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse_SuccessResult {
    fn default() -> &'a ExecuteCodeResponse_SuccessResult {
        <ExecuteCodeResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeResponse_SuccessResult {
    pub fn new() -> ExecuteCodeResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse_SuccessResult {
        ExecuteCodeResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ExecuteCodeResponse_SuccessResult| { &m.message },
                    |m: &mut ExecuteCodeResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse_SuccessResult>(
                    "ExecuteCodeResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse_ErrorResult {
    fn default() -> &'a ExecuteCodeResponse_ErrorResult {
        <ExecuteCodeResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeResponse_ErrorResult {
    pub fn new() -> ExecuteCodeResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse_ErrorResult {
        ExecuteCodeResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ExecuteCodeResponse_ErrorResult| { &m.message },
                    |m: &mut ExecuteCodeResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse_ErrorResult>(
                    "ExecuteCodeResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteCodeResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteCodeResponse_FailureResult {
    fn default() -> &'a ExecuteCodeResponse_FailureResult {
        <ExecuteCodeResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteCodeResponse_FailureResult {
    pub fn new() -> ExecuteCodeResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExecuteCodeResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteCodeResponse_FailureResult {
        ExecuteCodeResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ExecuteCodeResponse_FailureResult| { &m.message },
                    |m: &mut ExecuteCodeResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteCodeResponse_FailureResult>(
                    "ExecuteCodeResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteCodeResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteCodeResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ExecuteCodeResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteCodeResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteCodeResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteCodeResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineDeviceRequest {
    // message fields
    pub device_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineDeviceRequest {
    fn default() -> &'a DefineDeviceRequest {
        <DefineDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DefineDeviceRequest {
    pub fn new() -> DefineDeviceRequest {
        ::std::default::Default::default()
    }

    // int32 device_id = 1;


    pub fn get_device_id(&self) -> i32 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: i32) {
        self.device_id = v;
    }
}

impl ::protobuf::Message for DefineDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_int32(1, self.device_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineDeviceRequest {
        DefineDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_id",
                    |m: &DefineDeviceRequest| { &m.device_id },
                    |m: &mut DefineDeviceRequest| { &mut m.device_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineDeviceRequest>(
                    "DefineDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<DefineDeviceRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for DefineDeviceRequest {
    fn clear(&mut self) {
        self.device_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineDeviceResponse {
    // message oneof groups
    pub result: ::std::option::Option<DefineDeviceResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineDeviceResponse {
    fn default() -> &'a DefineDeviceResponse {
        <DefineDeviceResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DefineDeviceResponse_oneof_result {
    success_result(DefineDeviceResponse_SuccessResult),
    error_result(DefineDeviceResponse_ErrorResult),
    failure_result(DefineDeviceResponse_FailureResult),
}

impl DefineDeviceResponse {
    pub fn new() -> DefineDeviceResponse {
        ::std::default::Default::default()
    }

    // .DefineDeviceResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &DefineDeviceResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(ref v)) => v,
            _ => DefineDeviceResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: DefineDeviceResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut DefineDeviceResponse_SuccessResult {
        if let ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(DefineDeviceResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> DefineDeviceResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineDeviceResponse_SuccessResult::new()
        }
    }

    // .DefineDeviceResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &DefineDeviceResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(ref v)) => v,
            _ => DefineDeviceResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: DefineDeviceResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut DefineDeviceResponse_ErrorResult {
        if let ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(DefineDeviceResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> DefineDeviceResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineDeviceResponse_ErrorResult::new()
        }
    }

    // .DefineDeviceResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &DefineDeviceResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(ref v)) => v,
            _ => DefineDeviceResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: DefineDeviceResponse_FailureResult) {
        self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut DefineDeviceResponse_FailureResult {
        if let ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(DefineDeviceResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> DefineDeviceResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineDeviceResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for DefineDeviceResponse {
    fn is_initialized(&self) -> bool {
        if let Some(DefineDeviceResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineDeviceResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineDeviceResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineDeviceResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineDeviceResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineDeviceResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineDeviceResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineDeviceResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineDeviceResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineDeviceResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineDeviceResponse {
        DefineDeviceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineDeviceResponse_SuccessResult>(
                    "success_result",
                    DefineDeviceResponse::has_success_result,
                    DefineDeviceResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineDeviceResponse_ErrorResult>(
                    "error_result",
                    DefineDeviceResponse::has_error_result,
                    DefineDeviceResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineDeviceResponse_FailureResult>(
                    "failure_result",
                    DefineDeviceResponse::has_failure_result,
                    DefineDeviceResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineDeviceResponse>(
                    "DefineDeviceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineDeviceResponse {
        static mut instance: ::protobuf::lazy::Lazy<DefineDeviceResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineDeviceResponse::new)
        }
    }
}

impl ::protobuf::Clear for DefineDeviceResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineDeviceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineDeviceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineDeviceResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineDeviceResponse_SuccessResult {
    fn default() -> &'a DefineDeviceResponse_SuccessResult {
        <DefineDeviceResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineDeviceResponse_SuccessResult {
    pub fn new() -> DefineDeviceResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineDeviceResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineDeviceResponse_SuccessResult {
        DefineDeviceResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineDeviceResponse_SuccessResult| { &m.message },
                    |m: &mut DefineDeviceResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineDeviceResponse_SuccessResult>(
                    "DefineDeviceResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineDeviceResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineDeviceResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineDeviceResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineDeviceResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineDeviceResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineDeviceResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineDeviceResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineDeviceResponse_ErrorResult {
    fn default() -> &'a DefineDeviceResponse_ErrorResult {
        <DefineDeviceResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineDeviceResponse_ErrorResult {
    pub fn new() -> DefineDeviceResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineDeviceResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineDeviceResponse_ErrorResult {
        DefineDeviceResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineDeviceResponse_ErrorResult| { &m.message },
                    |m: &mut DefineDeviceResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineDeviceResponse_ErrorResult>(
                    "DefineDeviceResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineDeviceResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineDeviceResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineDeviceResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineDeviceResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineDeviceResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineDeviceResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineDeviceResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineDeviceResponse_FailureResult {
    fn default() -> &'a DefineDeviceResponse_FailureResult {
        <DefineDeviceResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineDeviceResponse_FailureResult {
    pub fn new() -> DefineDeviceResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineDeviceResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineDeviceResponse_FailureResult {
        DefineDeviceResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineDeviceResponse_FailureResult| { &m.message },
                    |m: &mut DefineDeviceResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineDeviceResponse_FailureResult>(
                    "DefineDeviceResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineDeviceResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineDeviceResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineDeviceResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineDeviceResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineDeviceResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineDeviceResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByPathRequest {
    // message fields
    pub device_path: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByPathRequest {
    fn default() -> &'a RemoveDeviceByPathRequest {
        <RemoveDeviceByPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByPathRequest {
    pub fn new() -> RemoveDeviceByPathRequest {
        ::std::default::Default::default()
    }

    // string device_path = 1;


    pub fn get_device_path(&self) -> &str {
        &self.device_path
    }
    pub fn clear_device_path(&mut self) {
        ::protobuf::Clear::clear(&mut self.device_path);
    }

    // Param is passed by value, moved
    pub fn set_device_path(&mut self, v: ::protobuf::Chars) {
        self.device_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_path(&mut self) -> &mut ::protobuf::Chars {
        &mut self.device_path
    }

    // Take field
    pub fn take_device_path(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.device_path, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByPathRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.device_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device_path.is_empty() {
            os.write_string(1, &self.device_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByPathRequest {
        RemoveDeviceByPathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "device_path",
                    |m: &RemoveDeviceByPathRequest| { &m.device_path },
                    |m: &mut RemoveDeviceByPathRequest| { &mut m.device_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByPathRequest>(
                    "RemoveDeviceByPathRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByPathRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByPathRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByPathRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByPathRequest {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.device_path);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByPathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByPathResponse {
    // message oneof groups
    pub result: ::std::option::Option<RemoveDeviceByPathResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByPathResponse {
    fn default() -> &'a RemoveDeviceByPathResponse {
        <RemoveDeviceByPathResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RemoveDeviceByPathResponse_oneof_result {
    success_result(RemoveDeviceByPathResponse_SuccessResult),
    error_result(RemoveDeviceByPathResponse_ErrorResult),
    failure_result(RemoveDeviceByPathResponse_FailureResult),
}

impl RemoveDeviceByPathResponse {
    pub fn new() -> RemoveDeviceByPathResponse {
        ::std::default::Default::default()
    }

    // .RemoveDeviceByPathResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &RemoveDeviceByPathResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(ref v)) => v,
            _ => RemoveDeviceByPathResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: RemoveDeviceByPathResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut RemoveDeviceByPathResponse_SuccessResult {
        if let ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(RemoveDeviceByPathResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> RemoveDeviceByPathResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByPathResponse_SuccessResult::new()
        }
    }

    // .RemoveDeviceByPathResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &RemoveDeviceByPathResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(ref v)) => v,
            _ => RemoveDeviceByPathResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: RemoveDeviceByPathResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut RemoveDeviceByPathResponse_ErrorResult {
        if let ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(RemoveDeviceByPathResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> RemoveDeviceByPathResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByPathResponse_ErrorResult::new()
        }
    }

    // .RemoveDeviceByPathResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &RemoveDeviceByPathResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(ref v)) => v,
            _ => RemoveDeviceByPathResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: RemoveDeviceByPathResponse_FailureResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut RemoveDeviceByPathResponse_FailureResult {
        if let ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(RemoveDeviceByPathResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> RemoveDeviceByPathResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByPathResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for RemoveDeviceByPathResponse {
    fn is_initialized(&self) -> bool {
        if let Some(RemoveDeviceByPathResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveDeviceByPathResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveDeviceByPathResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByPathResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveDeviceByPathResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveDeviceByPathResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveDeviceByPathResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveDeviceByPathResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveDeviceByPathResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveDeviceByPathResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByPathResponse {
        RemoveDeviceByPathResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByPathResponse_SuccessResult>(
                    "success_result",
                    RemoveDeviceByPathResponse::has_success_result,
                    RemoveDeviceByPathResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByPathResponse_ErrorResult>(
                    "error_result",
                    RemoveDeviceByPathResponse::has_error_result,
                    RemoveDeviceByPathResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByPathResponse_FailureResult>(
                    "failure_result",
                    RemoveDeviceByPathResponse::has_failure_result,
                    RemoveDeviceByPathResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByPathResponse>(
                    "RemoveDeviceByPathResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByPathResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByPathResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByPathResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByPathResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByPathResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByPathResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByPathResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByPathResponse_SuccessResult {
    fn default() -> &'a RemoveDeviceByPathResponse_SuccessResult {
        <RemoveDeviceByPathResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByPathResponse_SuccessResult {
    pub fn new() -> RemoveDeviceByPathResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByPathResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByPathResponse_SuccessResult {
        RemoveDeviceByPathResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByPathResponse_SuccessResult| { &m.message },
                    |m: &mut RemoveDeviceByPathResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByPathResponse_SuccessResult>(
                    "RemoveDeviceByPathResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByPathResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByPathResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByPathResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByPathResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByPathResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByPathResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByPathResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByPathResponse_ErrorResult {
    fn default() -> &'a RemoveDeviceByPathResponse_ErrorResult {
        <RemoveDeviceByPathResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByPathResponse_ErrorResult {
    pub fn new() -> RemoveDeviceByPathResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByPathResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByPathResponse_ErrorResult {
        RemoveDeviceByPathResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByPathResponse_ErrorResult| { &m.message },
                    |m: &mut RemoveDeviceByPathResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByPathResponse_ErrorResult>(
                    "RemoveDeviceByPathResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByPathResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByPathResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByPathResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByPathResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByPathResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByPathResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByPathResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByPathResponse_FailureResult {
    fn default() -> &'a RemoveDeviceByPathResponse_FailureResult {
        <RemoveDeviceByPathResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByPathResponse_FailureResult {
    pub fn new() -> RemoveDeviceByPathResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByPathResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByPathResponse_FailureResult {
        RemoveDeviceByPathResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByPathResponse_FailureResult| { &m.message },
                    |m: &mut RemoveDeviceByPathResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByPathResponse_FailureResult>(
                    "RemoveDeviceByPathResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByPathResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByPathResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByPathResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByPathResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByPathResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByPathResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByNameRequest {
    // message fields
    pub device_name: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByNameRequest {
    fn default() -> &'a RemoveDeviceByNameRequest {
        <RemoveDeviceByNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByNameRequest {
    pub fn new() -> RemoveDeviceByNameRequest {
        ::std::default::Default::default()
    }

    // string device_name = 1;


    pub fn get_device_name(&self) -> &str {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.device_name);
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::protobuf::Chars) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.device_name, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByNameRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.device_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device_name.is_empty() {
            os.write_string(1, &self.device_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByNameRequest {
        RemoveDeviceByNameRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "device_name",
                    |m: &RemoveDeviceByNameRequest| { &m.device_name },
                    |m: &mut RemoveDeviceByNameRequest| { &mut m.device_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByNameRequest>(
                    "RemoveDeviceByNameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByNameRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByNameRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByNameRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByNameRequest {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.device_name);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByNameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByNameResponse {
    // message oneof groups
    pub result: ::std::option::Option<RemoveDeviceByNameResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByNameResponse {
    fn default() -> &'a RemoveDeviceByNameResponse {
        <RemoveDeviceByNameResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RemoveDeviceByNameResponse_oneof_result {
    success_result(RemoveDeviceByNameResponse_SuccessResult),
    error_result(RemoveDeviceByNameResponse_ErrorResult),
    failure_result(RemoveDeviceByNameResponse_FailureResult),
}

impl RemoveDeviceByNameResponse {
    pub fn new() -> RemoveDeviceByNameResponse {
        ::std::default::Default::default()
    }

    // .RemoveDeviceByNameResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &RemoveDeviceByNameResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(ref v)) => v,
            _ => RemoveDeviceByNameResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: RemoveDeviceByNameResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut RemoveDeviceByNameResponse_SuccessResult {
        if let ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(RemoveDeviceByNameResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> RemoveDeviceByNameResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByNameResponse_SuccessResult::new()
        }
    }

    // .RemoveDeviceByNameResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &RemoveDeviceByNameResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(ref v)) => v,
            _ => RemoveDeviceByNameResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: RemoveDeviceByNameResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut RemoveDeviceByNameResponse_ErrorResult {
        if let ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(RemoveDeviceByNameResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> RemoveDeviceByNameResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByNameResponse_ErrorResult::new()
        }
    }

    // .RemoveDeviceByNameResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &RemoveDeviceByNameResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(ref v)) => v,
            _ => RemoveDeviceByNameResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: RemoveDeviceByNameResponse_FailureResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut RemoveDeviceByNameResponse_FailureResult {
        if let ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(RemoveDeviceByNameResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> RemoveDeviceByNameResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByNameResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for RemoveDeviceByNameResponse {
    fn is_initialized(&self) -> bool {
        if let Some(RemoveDeviceByNameResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveDeviceByNameResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveDeviceByNameResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByNameResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveDeviceByNameResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveDeviceByNameResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveDeviceByNameResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveDeviceByNameResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveDeviceByNameResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveDeviceByNameResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByNameResponse {
        RemoveDeviceByNameResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByNameResponse_SuccessResult>(
                    "success_result",
                    RemoveDeviceByNameResponse::has_success_result,
                    RemoveDeviceByNameResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByNameResponse_ErrorResult>(
                    "error_result",
                    RemoveDeviceByNameResponse::has_error_result,
                    RemoveDeviceByNameResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByNameResponse_FailureResult>(
                    "failure_result",
                    RemoveDeviceByNameResponse::has_failure_result,
                    RemoveDeviceByNameResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByNameResponse>(
                    "RemoveDeviceByNameResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByNameResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByNameResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByNameResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByNameResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByNameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByNameResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByNameResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByNameResponse_SuccessResult {
    fn default() -> &'a RemoveDeviceByNameResponse_SuccessResult {
        <RemoveDeviceByNameResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByNameResponse_SuccessResult {
    pub fn new() -> RemoveDeviceByNameResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByNameResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByNameResponse_SuccessResult {
        RemoveDeviceByNameResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByNameResponse_SuccessResult| { &m.message },
                    |m: &mut RemoveDeviceByNameResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByNameResponse_SuccessResult>(
                    "RemoveDeviceByNameResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByNameResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByNameResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByNameResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByNameResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByNameResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByNameResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByNameResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByNameResponse_ErrorResult {
    fn default() -> &'a RemoveDeviceByNameResponse_ErrorResult {
        <RemoveDeviceByNameResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByNameResponse_ErrorResult {
    pub fn new() -> RemoveDeviceByNameResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByNameResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByNameResponse_ErrorResult {
        RemoveDeviceByNameResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByNameResponse_ErrorResult| { &m.message },
                    |m: &mut RemoveDeviceByNameResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByNameResponse_ErrorResult>(
                    "RemoveDeviceByNameResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByNameResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByNameResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByNameResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByNameResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByNameResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByNameResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByNameResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByNameResponse_FailureResult {
    fn default() -> &'a RemoveDeviceByNameResponse_FailureResult {
        <RemoveDeviceByNameResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByNameResponse_FailureResult {
    pub fn new() -> RemoveDeviceByNameResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByNameResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByNameResponse_FailureResult {
        RemoveDeviceByNameResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByNameResponse_FailureResult| { &m.message },
                    |m: &mut RemoveDeviceByNameResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByNameResponse_FailureResult>(
                    "RemoveDeviceByNameResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByNameResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByNameResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByNameResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByNameResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByNameResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByNameResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByIdRequest {
    // message fields
    pub device_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByIdRequest {
    fn default() -> &'a RemoveDeviceByIdRequest {
        <RemoveDeviceByIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByIdRequest {
    pub fn new() -> RemoveDeviceByIdRequest {
        ::std::default::Default::default()
    }

    // int32 device_id = 1;


    pub fn get_device_id(&self) -> i32 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: i32) {
        self.device_id = v;
    }
}

impl ::protobuf::Message for RemoveDeviceByIdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_int32(1, self.device_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByIdRequest {
        RemoveDeviceByIdRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_id",
                    |m: &RemoveDeviceByIdRequest| { &m.device_id },
                    |m: &mut RemoveDeviceByIdRequest| { &mut m.device_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByIdRequest>(
                    "RemoveDeviceByIdRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByIdRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByIdRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByIdRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByIdRequest {
    fn clear(&mut self) {
        self.device_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByIdRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByIdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByIdResponse {
    // message oneof groups
    pub result: ::std::option::Option<RemoveDeviceByIdResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByIdResponse {
    fn default() -> &'a RemoveDeviceByIdResponse {
        <RemoveDeviceByIdResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RemoveDeviceByIdResponse_oneof_result {
    success_result(RemoveDeviceByIdResponse_SuccessResult),
    error_result(RemoveDeviceByIdResponse_ErrorResult),
    failure_result(RemoveDeviceByIdResponse_FailureResult),
}

impl RemoveDeviceByIdResponse {
    pub fn new() -> RemoveDeviceByIdResponse {
        ::std::default::Default::default()
    }

    // .RemoveDeviceByIdResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &RemoveDeviceByIdResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(ref v)) => v,
            _ => RemoveDeviceByIdResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: RemoveDeviceByIdResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut RemoveDeviceByIdResponse_SuccessResult {
        if let ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(RemoveDeviceByIdResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> RemoveDeviceByIdResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByIdResponse_SuccessResult::new()
        }
    }

    // .RemoveDeviceByIdResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &RemoveDeviceByIdResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(ref v)) => v,
            _ => RemoveDeviceByIdResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: RemoveDeviceByIdResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut RemoveDeviceByIdResponse_ErrorResult {
        if let ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(RemoveDeviceByIdResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> RemoveDeviceByIdResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByIdResponse_ErrorResult::new()
        }
    }

    // .RemoveDeviceByIdResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &RemoveDeviceByIdResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(ref v)) => v,
            _ => RemoveDeviceByIdResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: RemoveDeviceByIdResponse_FailureResult) {
        self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut RemoveDeviceByIdResponse_FailureResult {
        if let ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(RemoveDeviceByIdResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> RemoveDeviceByIdResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByIdResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for RemoveDeviceByIdResponse {
    fn is_initialized(&self) -> bool {
        if let Some(RemoveDeviceByIdResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveDeviceByIdResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveDeviceByIdResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveDeviceByIdResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveDeviceByIdResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveDeviceByIdResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveDeviceByIdResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveDeviceByIdResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveDeviceByIdResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveDeviceByIdResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByIdResponse {
        RemoveDeviceByIdResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByIdResponse_SuccessResult>(
                    "success_result",
                    RemoveDeviceByIdResponse::has_success_result,
                    RemoveDeviceByIdResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByIdResponse_ErrorResult>(
                    "error_result",
                    RemoveDeviceByIdResponse::has_error_result,
                    RemoveDeviceByIdResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByIdResponse_FailureResult>(
                    "failure_result",
                    RemoveDeviceByIdResponse::has_failure_result,
                    RemoveDeviceByIdResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByIdResponse>(
                    "RemoveDeviceByIdResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByIdResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByIdResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByIdResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByIdResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByIdResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByIdResponse_SuccessResult {
    fn default() -> &'a RemoveDeviceByIdResponse_SuccessResult {
        <RemoveDeviceByIdResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByIdResponse_SuccessResult {
    pub fn new() -> RemoveDeviceByIdResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByIdResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByIdResponse_SuccessResult {
        RemoveDeviceByIdResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByIdResponse_SuccessResult| { &m.message },
                    |m: &mut RemoveDeviceByIdResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByIdResponse_SuccessResult>(
                    "RemoveDeviceByIdResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByIdResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByIdResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByIdResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByIdResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByIdResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByIdResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByIdResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByIdResponse_ErrorResult {
    fn default() -> &'a RemoveDeviceByIdResponse_ErrorResult {
        <RemoveDeviceByIdResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByIdResponse_ErrorResult {
    pub fn new() -> RemoveDeviceByIdResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByIdResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByIdResponse_ErrorResult {
        RemoveDeviceByIdResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByIdResponse_ErrorResult| { &m.message },
                    |m: &mut RemoveDeviceByIdResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByIdResponse_ErrorResult>(
                    "RemoveDeviceByIdResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByIdResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByIdResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByIdResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByIdResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByIdResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByIdResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDeviceByIdResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveDeviceByIdResponse_FailureResult {
    fn default() -> &'a RemoveDeviceByIdResponse_FailureResult {
        <RemoveDeviceByIdResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveDeviceByIdResponse_FailureResult {
    pub fn new() -> RemoveDeviceByIdResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveDeviceByIdResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDeviceByIdResponse_FailureResult {
        RemoveDeviceByIdResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveDeviceByIdResponse_FailureResult| { &m.message },
                    |m: &mut RemoveDeviceByIdResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveDeviceByIdResponse_FailureResult>(
                    "RemoveDeviceByIdResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDeviceByIdResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDeviceByIdResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveDeviceByIdResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDeviceByIdResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDeviceByIdResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDeviceByIdResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedModifiersRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedModifiersRequest {
    fn default() -> &'a GetDefinedModifiersRequest {
        <GetDefinedModifiersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedModifiersRequest {
    pub fn new() -> GetDefinedModifiersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDefinedModifiersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedModifiersRequest {
        GetDefinedModifiersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedModifiersRequest>(
                    "GetDefinedModifiersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedModifiersRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedModifiersRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedModifiersRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedModifiersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedModifiersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedModifiersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedModifiersResponse {
    // message oneof groups
    pub result: ::std::option::Option<GetDefinedModifiersResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedModifiersResponse {
    fn default() -> &'a GetDefinedModifiersResponse {
        <GetDefinedModifiersResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetDefinedModifiersResponse_oneof_result {
    success_result(GetDefinedModifiersResponse_SuccessResult),
    error_result(GetDefinedModifiersResponse_ErrorResult),
    failure_result(GetDefinedModifiersResponse_FailureResult),
}

impl GetDefinedModifiersResponse {
    pub fn new() -> GetDefinedModifiersResponse {
        ::std::default::Default::default()
    }

    // .GetDefinedModifiersResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &GetDefinedModifiersResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(ref v)) => v,
            _ => GetDefinedModifiersResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: GetDefinedModifiersResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut GetDefinedModifiersResponse_SuccessResult {
        if let ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(GetDefinedModifiersResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> GetDefinedModifiersResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedModifiersResponse_SuccessResult::new()
        }
    }

    // .GetDefinedModifiersResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &GetDefinedModifiersResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(ref v)) => v,
            _ => GetDefinedModifiersResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: GetDefinedModifiersResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut GetDefinedModifiersResponse_ErrorResult {
        if let ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(GetDefinedModifiersResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> GetDefinedModifiersResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedModifiersResponse_ErrorResult::new()
        }
    }

    // .GetDefinedModifiersResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &GetDefinedModifiersResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(ref v)) => v,
            _ => GetDefinedModifiersResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: GetDefinedModifiersResponse_FailureResult) {
        self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut GetDefinedModifiersResponse_FailureResult {
        if let ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(GetDefinedModifiersResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> GetDefinedModifiersResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedModifiersResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for GetDefinedModifiersResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetDefinedModifiersResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDefinedModifiersResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDefinedModifiersResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedModifiersResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDefinedModifiersResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDefinedModifiersResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDefinedModifiersResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDefinedModifiersResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDefinedModifiersResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDefinedModifiersResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedModifiersResponse {
        GetDefinedModifiersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedModifiersResponse_SuccessResult>(
                    "success_result",
                    GetDefinedModifiersResponse::has_success_result,
                    GetDefinedModifiersResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedModifiersResponse_ErrorResult>(
                    "error_result",
                    GetDefinedModifiersResponse::has_error_result,
                    GetDefinedModifiersResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedModifiersResponse_FailureResult>(
                    "failure_result",
                    GetDefinedModifiersResponse::has_failure_result,
                    GetDefinedModifiersResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedModifiersResponse>(
                    "GetDefinedModifiersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedModifiersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedModifiersResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedModifiersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedModifiersResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedModifiersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedModifiersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedModifiersResponse_SuccessResult {
    // message fields
    pub modifier_descriptions: ::protobuf::RepeatedField<ModifierDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedModifiersResponse_SuccessResult {
    fn default() -> &'a GetDefinedModifiersResponse_SuccessResult {
        <GetDefinedModifiersResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedModifiersResponse_SuccessResult {
    pub fn new() -> GetDefinedModifiersResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // repeated .ModifierDescription modifier_descriptions = 1;


    pub fn get_modifier_descriptions(&self) -> &[ModifierDescription] {
        &self.modifier_descriptions
    }
    pub fn clear_modifier_descriptions(&mut self) {
        self.modifier_descriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifier_descriptions(&mut self, v: ::protobuf::RepeatedField<ModifierDescription>) {
        self.modifier_descriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifier_descriptions(&mut self) -> &mut ::protobuf::RepeatedField<ModifierDescription> {
        &mut self.modifier_descriptions
    }

    // Take field
    pub fn take_modifier_descriptions(&mut self) -> ::protobuf::RepeatedField<ModifierDescription> {
        ::std::mem::replace(&mut self.modifier_descriptions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDefinedModifiersResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        for v in &self.modifier_descriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifier_descriptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.modifier_descriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.modifier_descriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedModifiersResponse_SuccessResult {
        GetDefinedModifiersResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifierDescription>>(
                    "modifier_descriptions",
                    |m: &GetDefinedModifiersResponse_SuccessResult| { &m.modifier_descriptions },
                    |m: &mut GetDefinedModifiersResponse_SuccessResult| { &mut m.modifier_descriptions },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedModifiersResponse_SuccessResult>(
                    "GetDefinedModifiersResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedModifiersResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedModifiersResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedModifiersResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedModifiersResponse_SuccessResult {
    fn clear(&mut self) {
        self.modifier_descriptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedModifiersResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedModifiersResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedModifiersResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedModifiersResponse_ErrorResult {
    fn default() -> &'a GetDefinedModifiersResponse_ErrorResult {
        <GetDefinedModifiersResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedModifiersResponse_ErrorResult {
    pub fn new() -> GetDefinedModifiersResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDefinedModifiersResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedModifiersResponse_ErrorResult {
        GetDefinedModifiersResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDefinedModifiersResponse_ErrorResult| { &m.message },
                    |m: &mut GetDefinedModifiersResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedModifiersResponse_ErrorResult>(
                    "GetDefinedModifiersResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedModifiersResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedModifiersResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedModifiersResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedModifiersResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedModifiersResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedModifiersResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedModifiersResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedModifiersResponse_FailureResult {
    fn default() -> &'a GetDefinedModifiersResponse_FailureResult {
        <GetDefinedModifiersResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedModifiersResponse_FailureResult {
    pub fn new() -> GetDefinedModifiersResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDefinedModifiersResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedModifiersResponse_FailureResult {
        GetDefinedModifiersResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDefinedModifiersResponse_FailureResult| { &m.message },
                    |m: &mut GetDefinedModifiersResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedModifiersResponse_FailureResult>(
                    "GetDefinedModifiersResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedModifiersResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedModifiersResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedModifiersResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedModifiersResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedModifiersResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedModifiersResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineModifierRequest {
    // message fields
    pub modifier: ::protobuf::SingularPtrField<ModifierDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineModifierRequest {
    fn default() -> &'a DefineModifierRequest {
        <DefineModifierRequest as ::protobuf::Message>::default_instance()
    }
}

impl DefineModifierRequest {
    pub fn new() -> DefineModifierRequest {
        ::std::default::Default::default()
    }

    // .ModifierDescription modifier = 1;


    pub fn get_modifier(&self) -> &ModifierDescription {
        self.modifier.as_ref().unwrap_or_else(|| ModifierDescription::default_instance())
    }
    pub fn clear_modifier(&mut self) {
        self.modifier.clear();
    }

    pub fn has_modifier(&self) -> bool {
        self.modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier(&mut self, v: ModifierDescription) {
        self.modifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifier(&mut self) -> &mut ModifierDescription {
        if self.modifier.is_none() {
            self.modifier.set_default();
        }
        self.modifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifier(&mut self) -> ModifierDescription {
        self.modifier.take().unwrap_or_else(|| ModifierDescription::new())
    }
}

impl ::protobuf::Message for DefineModifierRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.modifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.modifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.modifier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineModifierRequest {
        DefineModifierRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifierDescription>>(
                    "modifier",
                    |m: &DefineModifierRequest| { &m.modifier },
                    |m: &mut DefineModifierRequest| { &mut m.modifier },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineModifierRequest>(
                    "DefineModifierRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineModifierRequest {
        static mut instance: ::protobuf::lazy::Lazy<DefineModifierRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineModifierRequest::new)
        }
    }
}

impl ::protobuf::Clear for DefineModifierRequest {
    fn clear(&mut self) {
        self.modifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineModifierRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineModifierRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineModifierResponse {
    // message oneof groups
    pub result: ::std::option::Option<DefineModifierResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineModifierResponse {
    fn default() -> &'a DefineModifierResponse {
        <DefineModifierResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DefineModifierResponse_oneof_result {
    success_result(DefineModifierResponse_SuccessResult),
    error_result(DefineModifierResponse_ErrorResult),
    failure_result(DefineModifierResponse_FailureResult),
}

impl DefineModifierResponse {
    pub fn new() -> DefineModifierResponse {
        ::std::default::Default::default()
    }

    // .DefineModifierResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &DefineModifierResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(ref v)) => v,
            _ => DefineModifierResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: DefineModifierResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut DefineModifierResponse_SuccessResult {
        if let ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(DefineModifierResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> DefineModifierResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineModifierResponse_SuccessResult::new()
        }
    }

    // .DefineModifierResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &DefineModifierResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(ref v)) => v,
            _ => DefineModifierResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: DefineModifierResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut DefineModifierResponse_ErrorResult {
        if let ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(DefineModifierResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> DefineModifierResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineModifierResponse_ErrorResult::new()
        }
    }

    // .DefineModifierResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &DefineModifierResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(ref v)) => v,
            _ => DefineModifierResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: DefineModifierResponse_FailureResult) {
        self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut DefineModifierResponse_FailureResult {
        if let ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(DefineModifierResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> DefineModifierResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineModifierResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for DefineModifierResponse {
    fn is_initialized(&self) -> bool {
        if let Some(DefineModifierResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineModifierResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineModifierResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineModifierResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineModifierResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineModifierResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineModifierResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineModifierResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineModifierResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineModifierResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineModifierResponse {
        DefineModifierResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineModifierResponse_SuccessResult>(
                    "success_result",
                    DefineModifierResponse::has_success_result,
                    DefineModifierResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineModifierResponse_ErrorResult>(
                    "error_result",
                    DefineModifierResponse::has_error_result,
                    DefineModifierResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineModifierResponse_FailureResult>(
                    "failure_result",
                    DefineModifierResponse::has_failure_result,
                    DefineModifierResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineModifierResponse>(
                    "DefineModifierResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineModifierResponse {
        static mut instance: ::protobuf::lazy::Lazy<DefineModifierResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineModifierResponse::new)
        }
    }
}

impl ::protobuf::Clear for DefineModifierResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineModifierResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineModifierResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineModifierResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineModifierResponse_SuccessResult {
    fn default() -> &'a DefineModifierResponse_SuccessResult {
        <DefineModifierResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineModifierResponse_SuccessResult {
    pub fn new() -> DefineModifierResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineModifierResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineModifierResponse_SuccessResult {
        DefineModifierResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineModifierResponse_SuccessResult| { &m.message },
                    |m: &mut DefineModifierResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineModifierResponse_SuccessResult>(
                    "DefineModifierResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineModifierResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineModifierResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineModifierResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineModifierResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineModifierResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineModifierResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineModifierResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineModifierResponse_ErrorResult {
    fn default() -> &'a DefineModifierResponse_ErrorResult {
        <DefineModifierResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineModifierResponse_ErrorResult {
    pub fn new() -> DefineModifierResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineModifierResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineModifierResponse_ErrorResult {
        DefineModifierResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineModifierResponse_ErrorResult| { &m.message },
                    |m: &mut DefineModifierResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineModifierResponse_ErrorResult>(
                    "DefineModifierResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineModifierResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineModifierResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineModifierResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineModifierResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineModifierResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineModifierResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineModifierResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineModifierResponse_FailureResult {
    fn default() -> &'a DefineModifierResponse_FailureResult {
        <DefineModifierResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineModifierResponse_FailureResult {
    pub fn new() -> DefineModifierResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineModifierResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineModifierResponse_FailureResult {
        DefineModifierResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineModifierResponse_FailureResult| { &m.message },
                    |m: &mut DefineModifierResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineModifierResponse_FailureResult>(
                    "DefineModifierResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineModifierResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineModifierResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineModifierResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineModifierResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineModifierResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineModifierResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveModifierRequest {
    // message fields
    pub modifier_key: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveModifierRequest {
    fn default() -> &'a RemoveModifierRequest {
        <RemoveModifierRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveModifierRequest {
    pub fn new() -> RemoveModifierRequest {
        ::std::default::Default::default()
    }

    // .Key modifier_key = 1;


    pub fn get_modifier_key(&self) -> &Key {
        self.modifier_key.as_ref().unwrap_or_else(|| Key::default_instance())
    }
    pub fn clear_modifier_key(&mut self) {
        self.modifier_key.clear();
    }

    pub fn has_modifier_key(&self) -> bool {
        self.modifier_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier_key(&mut self, v: Key) {
        self.modifier_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifier_key(&mut self) -> &mut Key {
        if self.modifier_key.is_none() {
            self.modifier_key.set_default();
        }
        self.modifier_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifier_key(&mut self) -> Key {
        self.modifier_key.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for RemoveModifierRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.modifier_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifier_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.modifier_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.modifier_key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveModifierRequest {
        RemoveModifierRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "modifier_key",
                    |m: &RemoveModifierRequest| { &m.modifier_key },
                    |m: &mut RemoveModifierRequest| { &mut m.modifier_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveModifierRequest>(
                    "RemoveModifierRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveModifierRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveModifierRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveModifierRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveModifierRequest {
    fn clear(&mut self) {
        self.modifier_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveModifierRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveModifierRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveModifierResponse {
    // message oneof groups
    pub result: ::std::option::Option<RemoveModifierResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveModifierResponse {
    fn default() -> &'a RemoveModifierResponse {
        <RemoveModifierResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RemoveModifierResponse_oneof_result {
    success_result(RemoveModifierResponse_SuccessResult),
    error_result(RemoveModifierResponse_ErrorResult),
    failure_result(RemoveModifierResponse_FailureResult),
}

impl RemoveModifierResponse {
    pub fn new() -> RemoveModifierResponse {
        ::std::default::Default::default()
    }

    // .RemoveModifierResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &RemoveModifierResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(ref v)) => v,
            _ => RemoveModifierResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: RemoveModifierResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut RemoveModifierResponse_SuccessResult {
        if let ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(RemoveModifierResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> RemoveModifierResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveModifierResponse_SuccessResult::new()
        }
    }

    // .RemoveModifierResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &RemoveModifierResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(ref v)) => v,
            _ => RemoveModifierResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: RemoveModifierResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut RemoveModifierResponse_ErrorResult {
        if let ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(RemoveModifierResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> RemoveModifierResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveModifierResponse_ErrorResult::new()
        }
    }

    // .RemoveModifierResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &RemoveModifierResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(ref v)) => v,
            _ => RemoveModifierResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: RemoveModifierResponse_FailureResult) {
        self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut RemoveModifierResponse_FailureResult {
        if let ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(RemoveModifierResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> RemoveModifierResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveModifierResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for RemoveModifierResponse {
    fn is_initialized(&self) -> bool {
        if let Some(RemoveModifierResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveModifierResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveModifierResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveModifierResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveModifierResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveModifierResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveModifierResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveModifierResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveModifierResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveModifierResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveModifierResponse {
        RemoveModifierResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveModifierResponse_SuccessResult>(
                    "success_result",
                    RemoveModifierResponse::has_success_result,
                    RemoveModifierResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveModifierResponse_ErrorResult>(
                    "error_result",
                    RemoveModifierResponse::has_error_result,
                    RemoveModifierResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveModifierResponse_FailureResult>(
                    "failure_result",
                    RemoveModifierResponse::has_failure_result,
                    RemoveModifierResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveModifierResponse>(
                    "RemoveModifierResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveModifierResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveModifierResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveModifierResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveModifierResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveModifierResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveModifierResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveModifierResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveModifierResponse_SuccessResult {
    fn default() -> &'a RemoveModifierResponse_SuccessResult {
        <RemoveModifierResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveModifierResponse_SuccessResult {
    pub fn new() -> RemoveModifierResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveModifierResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveModifierResponse_SuccessResult {
        RemoveModifierResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveModifierResponse_SuccessResult| { &m.message },
                    |m: &mut RemoveModifierResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveModifierResponse_SuccessResult>(
                    "RemoveModifierResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveModifierResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveModifierResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveModifierResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveModifierResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveModifierResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveModifierResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveModifierResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveModifierResponse_ErrorResult {
    fn default() -> &'a RemoveModifierResponse_ErrorResult {
        <RemoveModifierResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveModifierResponse_ErrorResult {
    pub fn new() -> RemoveModifierResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveModifierResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveModifierResponse_ErrorResult {
        RemoveModifierResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveModifierResponse_ErrorResult| { &m.message },
                    |m: &mut RemoveModifierResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveModifierResponse_ErrorResult>(
                    "RemoveModifierResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveModifierResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveModifierResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveModifierResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveModifierResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveModifierResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveModifierResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveModifierResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveModifierResponse_FailureResult {
    fn default() -> &'a RemoveModifierResponse_FailureResult {
        <RemoveModifierResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveModifierResponse_FailureResult {
    pub fn new() -> RemoveModifierResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveModifierResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveModifierResponse_FailureResult {
        RemoveModifierResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveModifierResponse_FailureResult| { &m.message },
                    |m: &mut RemoveModifierResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveModifierResponse_FailureResult>(
                    "RemoveModifierResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveModifierResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveModifierResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveModifierResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveModifierResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveModifierResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveModifierResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedActionsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedActionsRequest {
    fn default() -> &'a GetDefinedActionsRequest {
        <GetDefinedActionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedActionsRequest {
    pub fn new() -> GetDefinedActionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDefinedActionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedActionsRequest {
        GetDefinedActionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedActionsRequest>(
                    "GetDefinedActionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedActionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedActionsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedActionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedActionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedActionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedActionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedActionsResponse {
    // message oneof groups
    pub result: ::std::option::Option<GetDefinedActionsResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedActionsResponse {
    fn default() -> &'a GetDefinedActionsResponse {
        <GetDefinedActionsResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetDefinedActionsResponse_oneof_result {
    success_result(GetDefinedActionsResponse_SuccessResult),
    error_result(GetDefinedActionsResponse_ErrorResult),
    failure_result(GetDefinedActionsResponse_FailureResult),
}

impl GetDefinedActionsResponse {
    pub fn new() -> GetDefinedActionsResponse {
        ::std::default::Default::default()
    }

    // .GetDefinedActionsResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &GetDefinedActionsResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(ref v)) => v,
            _ => GetDefinedActionsResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: GetDefinedActionsResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut GetDefinedActionsResponse_SuccessResult {
        if let ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(GetDefinedActionsResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> GetDefinedActionsResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedActionsResponse_SuccessResult::new()
        }
    }

    // .GetDefinedActionsResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &GetDefinedActionsResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(ref v)) => v,
            _ => GetDefinedActionsResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: GetDefinedActionsResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut GetDefinedActionsResponse_ErrorResult {
        if let ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(GetDefinedActionsResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> GetDefinedActionsResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedActionsResponse_ErrorResult::new()
        }
    }

    // .GetDefinedActionsResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &GetDefinedActionsResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(ref v)) => v,
            _ => GetDefinedActionsResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: GetDefinedActionsResponse_FailureResult) {
        self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut GetDefinedActionsResponse_FailureResult {
        if let ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(GetDefinedActionsResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> GetDefinedActionsResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedActionsResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for GetDefinedActionsResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetDefinedActionsResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDefinedActionsResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDefinedActionsResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedActionsResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDefinedActionsResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDefinedActionsResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDefinedActionsResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDefinedActionsResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDefinedActionsResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDefinedActionsResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedActionsResponse {
        GetDefinedActionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedActionsResponse_SuccessResult>(
                    "success_result",
                    GetDefinedActionsResponse::has_success_result,
                    GetDefinedActionsResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedActionsResponse_ErrorResult>(
                    "error_result",
                    GetDefinedActionsResponse::has_error_result,
                    GetDefinedActionsResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedActionsResponse_FailureResult>(
                    "failure_result",
                    GetDefinedActionsResponse::has_failure_result,
                    GetDefinedActionsResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedActionsResponse>(
                    "GetDefinedActionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedActionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedActionsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedActionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedActionsResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedActionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedActionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedActionsResponse_SuccessResult {
    // message fields
    pub named_actions: ::protobuf::RepeatedField<NamedAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedActionsResponse_SuccessResult {
    fn default() -> &'a GetDefinedActionsResponse_SuccessResult {
        <GetDefinedActionsResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedActionsResponse_SuccessResult {
    pub fn new() -> GetDefinedActionsResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // repeated .NamedAction named_actions = 1;


    pub fn get_named_actions(&self) -> &[NamedAction] {
        &self.named_actions
    }
    pub fn clear_named_actions(&mut self) {
        self.named_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_named_actions(&mut self, v: ::protobuf::RepeatedField<NamedAction>) {
        self.named_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_named_actions(&mut self) -> &mut ::protobuf::RepeatedField<NamedAction> {
        &mut self.named_actions
    }

    // Take field
    pub fn take_named_actions(&mut self) -> ::protobuf::RepeatedField<NamedAction> {
        ::std::mem::replace(&mut self.named_actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDefinedActionsResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        for v in &self.named_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.named_actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.named_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.named_actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedActionsResponse_SuccessResult {
        GetDefinedActionsResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamedAction>>(
                    "named_actions",
                    |m: &GetDefinedActionsResponse_SuccessResult| { &m.named_actions },
                    |m: &mut GetDefinedActionsResponse_SuccessResult| { &mut m.named_actions },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedActionsResponse_SuccessResult>(
                    "GetDefinedActionsResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedActionsResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedActionsResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedActionsResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedActionsResponse_SuccessResult {
    fn clear(&mut self) {
        self.named_actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedActionsResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedActionsResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedActionsResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedActionsResponse_ErrorResult {
    fn default() -> &'a GetDefinedActionsResponse_ErrorResult {
        <GetDefinedActionsResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedActionsResponse_ErrorResult {
    pub fn new() -> GetDefinedActionsResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDefinedActionsResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedActionsResponse_ErrorResult {
        GetDefinedActionsResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDefinedActionsResponse_ErrorResult| { &m.message },
                    |m: &mut GetDefinedActionsResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedActionsResponse_ErrorResult>(
                    "GetDefinedActionsResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedActionsResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedActionsResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedActionsResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedActionsResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedActionsResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedActionsResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedActionsResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedActionsResponse_FailureResult {
    fn default() -> &'a GetDefinedActionsResponse_FailureResult {
        <GetDefinedActionsResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedActionsResponse_FailureResult {
    pub fn new() -> GetDefinedActionsResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDefinedActionsResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedActionsResponse_FailureResult {
        GetDefinedActionsResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDefinedActionsResponse_FailureResult| { &m.message },
                    |m: &mut GetDefinedActionsResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedActionsResponse_FailureResult>(
                    "GetDefinedActionsResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedActionsResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedActionsResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedActionsResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedActionsResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedActionsResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedActionsResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineActionRequest {
    // message fields
    pub action: ::protobuf::SingularPtrField<NamedAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineActionRequest {
    fn default() -> &'a DefineActionRequest {
        <DefineActionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DefineActionRequest {
    pub fn new() -> DefineActionRequest {
        ::std::default::Default::default()
    }

    // .NamedAction action = 1;


    pub fn get_action(&self) -> &NamedAction {
        self.action.as_ref().unwrap_or_else(|| NamedAction::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: NamedAction) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut NamedAction {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> NamedAction {
        self.action.take().unwrap_or_else(|| NamedAction::new())
    }
}

impl ::protobuf::Message for DefineActionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineActionRequest {
        DefineActionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamedAction>>(
                    "action",
                    |m: &DefineActionRequest| { &m.action },
                    |m: &mut DefineActionRequest| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineActionRequest>(
                    "DefineActionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineActionRequest {
        static mut instance: ::protobuf::lazy::Lazy<DefineActionRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineActionRequest::new)
        }
    }
}

impl ::protobuf::Clear for DefineActionRequest {
    fn clear(&mut self) {
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineActionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineActionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineActionResponse {
    // message oneof groups
    pub result: ::std::option::Option<DefineActionResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineActionResponse {
    fn default() -> &'a DefineActionResponse {
        <DefineActionResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DefineActionResponse_oneof_result {
    success_result(DefineActionResponse_SuccessResult),
    error_result(DefineActionResponse_ErrorResult),
    failure_result(DefineActionResponse_FailureResult),
}

impl DefineActionResponse {
    pub fn new() -> DefineActionResponse {
        ::std::default::Default::default()
    }

    // .DefineActionResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &DefineActionResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(ref v)) => v,
            _ => DefineActionResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: DefineActionResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut DefineActionResponse_SuccessResult {
        if let ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(DefineActionResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> DefineActionResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineActionResponse_SuccessResult::new()
        }
    }

    // .DefineActionResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &DefineActionResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(ref v)) => v,
            _ => DefineActionResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: DefineActionResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut DefineActionResponse_ErrorResult {
        if let ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(DefineActionResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> DefineActionResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineActionResponse_ErrorResult::new()
        }
    }

    // .DefineActionResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &DefineActionResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(ref v)) => v,
            _ => DefineActionResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: DefineActionResponse_FailureResult) {
        self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut DefineActionResponse_FailureResult {
        if let ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(DefineActionResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> DefineActionResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineActionResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for DefineActionResponse {
    fn is_initialized(&self) -> bool {
        if let Some(DefineActionResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineActionResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineActionResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineActionResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineActionResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineActionResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineActionResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineActionResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineActionResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineActionResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineActionResponse {
        DefineActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineActionResponse_SuccessResult>(
                    "success_result",
                    DefineActionResponse::has_success_result,
                    DefineActionResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineActionResponse_ErrorResult>(
                    "error_result",
                    DefineActionResponse::has_error_result,
                    DefineActionResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineActionResponse_FailureResult>(
                    "failure_result",
                    DefineActionResponse::has_failure_result,
                    DefineActionResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineActionResponse>(
                    "DefineActionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineActionResponse {
        static mut instance: ::protobuf::lazy::Lazy<DefineActionResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineActionResponse::new)
        }
    }
}

impl ::protobuf::Clear for DefineActionResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineActionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineActionResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineActionResponse_SuccessResult {
    fn default() -> &'a DefineActionResponse_SuccessResult {
        <DefineActionResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineActionResponse_SuccessResult {
    pub fn new() -> DefineActionResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineActionResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineActionResponse_SuccessResult {
        DefineActionResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineActionResponse_SuccessResult| { &m.message },
                    |m: &mut DefineActionResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineActionResponse_SuccessResult>(
                    "DefineActionResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineActionResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineActionResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineActionResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineActionResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineActionResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineActionResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineActionResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineActionResponse_ErrorResult {
    fn default() -> &'a DefineActionResponse_ErrorResult {
        <DefineActionResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineActionResponse_ErrorResult {
    pub fn new() -> DefineActionResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineActionResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineActionResponse_ErrorResult {
        DefineActionResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineActionResponse_ErrorResult| { &m.message },
                    |m: &mut DefineActionResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineActionResponse_ErrorResult>(
                    "DefineActionResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineActionResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineActionResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineActionResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineActionResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineActionResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineActionResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineActionResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineActionResponse_FailureResult {
    fn default() -> &'a DefineActionResponse_FailureResult {
        <DefineActionResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineActionResponse_FailureResult {
    pub fn new() -> DefineActionResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineActionResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineActionResponse_FailureResult {
        DefineActionResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineActionResponse_FailureResult| { &m.message },
                    |m: &mut DefineActionResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineActionResponse_FailureResult>(
                    "DefineActionResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineActionResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineActionResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineActionResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineActionResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineActionResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineActionResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveActionRequest {
    // message fields
    pub action_name: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveActionRequest {
    fn default() -> &'a RemoveActionRequest {
        <RemoveActionRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveActionRequest {
    pub fn new() -> RemoveActionRequest {
        ::std::default::Default::default()
    }

    // string action_name = 1;


    pub fn get_action_name(&self) -> &str {
        &self.action_name
    }
    pub fn clear_action_name(&mut self) {
        ::protobuf::Clear::clear(&mut self.action_name);
    }

    // Param is passed by value, moved
    pub fn set_action_name(&mut self, v: ::protobuf::Chars) {
        self.action_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_name(&mut self) -> &mut ::protobuf::Chars {
        &mut self.action_name
    }

    // Take field
    pub fn take_action_name(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.action_name, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveActionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.action_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.action_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.action_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.action_name.is_empty() {
            os.write_string(1, &self.action_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveActionRequest {
        RemoveActionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "action_name",
                    |m: &RemoveActionRequest| { &m.action_name },
                    |m: &mut RemoveActionRequest| { &mut m.action_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveActionRequest>(
                    "RemoveActionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveActionRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveActionRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveActionRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveActionRequest {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.action_name);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveActionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveActionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveActionResponse {
    // message oneof groups
    pub result: ::std::option::Option<RemoveActionResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveActionResponse {
    fn default() -> &'a RemoveActionResponse {
        <RemoveActionResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RemoveActionResponse_oneof_result {
    success_result(RemoveActionResponse_SuccessResult),
    error_result(RemoveActionResponse_ErrorResult),
    failure_result(RemoveActionResponse_FailureResult),
}

impl RemoveActionResponse {
    pub fn new() -> RemoveActionResponse {
        ::std::default::Default::default()
    }

    // .RemoveActionResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &RemoveActionResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(ref v)) => v,
            _ => RemoveActionResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: RemoveActionResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut RemoveActionResponse_SuccessResult {
        if let ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(RemoveActionResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> RemoveActionResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveActionResponse_SuccessResult::new()
        }
    }

    // .RemoveActionResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &RemoveActionResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(ref v)) => v,
            _ => RemoveActionResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: RemoveActionResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut RemoveActionResponse_ErrorResult {
        if let ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(RemoveActionResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> RemoveActionResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveActionResponse_ErrorResult::new()
        }
    }

    // .RemoveActionResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &RemoveActionResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(ref v)) => v,
            _ => RemoveActionResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: RemoveActionResponse_FailureResult) {
        self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut RemoveActionResponse_FailureResult {
        if let ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(RemoveActionResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> RemoveActionResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveActionResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for RemoveActionResponse {
    fn is_initialized(&self) -> bool {
        if let Some(RemoveActionResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveActionResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveActionResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveActionResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveActionResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveActionResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveActionResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveActionResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveActionResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveActionResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveActionResponse {
        RemoveActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveActionResponse_SuccessResult>(
                    "success_result",
                    RemoveActionResponse::has_success_result,
                    RemoveActionResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveActionResponse_ErrorResult>(
                    "error_result",
                    RemoveActionResponse::has_error_result,
                    RemoveActionResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveActionResponse_FailureResult>(
                    "failure_result",
                    RemoveActionResponse::has_failure_result,
                    RemoveActionResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveActionResponse>(
                    "RemoveActionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveActionResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveActionResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveActionResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveActionResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveActionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveActionResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveActionResponse_SuccessResult {
    fn default() -> &'a RemoveActionResponse_SuccessResult {
        <RemoveActionResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveActionResponse_SuccessResult {
    pub fn new() -> RemoveActionResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveActionResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveActionResponse_SuccessResult {
        RemoveActionResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveActionResponse_SuccessResult| { &m.message },
                    |m: &mut RemoveActionResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveActionResponse_SuccessResult>(
                    "RemoveActionResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveActionResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveActionResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveActionResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveActionResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveActionResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveActionResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveActionResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveActionResponse_ErrorResult {
    fn default() -> &'a RemoveActionResponse_ErrorResult {
        <RemoveActionResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveActionResponse_ErrorResult {
    pub fn new() -> RemoveActionResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveActionResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveActionResponse_ErrorResult {
        RemoveActionResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveActionResponse_ErrorResult| { &m.message },
                    |m: &mut RemoveActionResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveActionResponse_ErrorResult>(
                    "RemoveActionResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveActionResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveActionResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveActionResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveActionResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveActionResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveActionResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveActionResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveActionResponse_FailureResult {
    fn default() -> &'a RemoveActionResponse_FailureResult {
        <RemoveActionResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveActionResponse_FailureResult {
    pub fn new() -> RemoveActionResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveActionResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveActionResponse_FailureResult {
        RemoveActionResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveActionResponse_FailureResult| { &m.message },
                    |m: &mut RemoveActionResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveActionResponse_FailureResult>(
                    "RemoveActionResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveActionResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveActionResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveActionResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveActionResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveActionResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveActionResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedMappingsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedMappingsRequest {
    fn default() -> &'a GetDefinedMappingsRequest {
        <GetDefinedMappingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedMappingsRequest {
    pub fn new() -> GetDefinedMappingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDefinedMappingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedMappingsRequest {
        GetDefinedMappingsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedMappingsRequest>(
                    "GetDefinedMappingsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedMappingsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedMappingsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedMappingsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedMappingsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedMappingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedMappingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedMappingsResponse {
    // message oneof groups
    pub result: ::std::option::Option<GetDefinedMappingsResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedMappingsResponse {
    fn default() -> &'a GetDefinedMappingsResponse {
        <GetDefinedMappingsResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetDefinedMappingsResponse_oneof_result {
    success_result(GetDefinedMappingsResponse_SuccessResult),
    error_result(GetDefinedMappingsResponse_ErrorResult),
    failure_result(GetDefinedMappingsResponse_FailureResult),
}

impl GetDefinedMappingsResponse {
    pub fn new() -> GetDefinedMappingsResponse {
        ::std::default::Default::default()
    }

    // .GetDefinedMappingsResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &GetDefinedMappingsResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(ref v)) => v,
            _ => GetDefinedMappingsResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: GetDefinedMappingsResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut GetDefinedMappingsResponse_SuccessResult {
        if let ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(GetDefinedMappingsResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> GetDefinedMappingsResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedMappingsResponse_SuccessResult::new()
        }
    }

    // .GetDefinedMappingsResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &GetDefinedMappingsResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(ref v)) => v,
            _ => GetDefinedMappingsResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: GetDefinedMappingsResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut GetDefinedMappingsResponse_ErrorResult {
        if let ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(GetDefinedMappingsResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> GetDefinedMappingsResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedMappingsResponse_ErrorResult::new()
        }
    }

    // .GetDefinedMappingsResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &GetDefinedMappingsResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(ref v)) => v,
            _ => GetDefinedMappingsResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: GetDefinedMappingsResponse_FailureResult) {
        self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut GetDefinedMappingsResponse_FailureResult {
        if let ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(GetDefinedMappingsResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> GetDefinedMappingsResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedMappingsResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for GetDefinedMappingsResponse {
    fn is_initialized(&self) -> bool {
        if let Some(GetDefinedMappingsResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDefinedMappingsResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GetDefinedMappingsResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(GetDefinedMappingsResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDefinedMappingsResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDefinedMappingsResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GetDefinedMappingsResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &GetDefinedMappingsResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDefinedMappingsResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GetDefinedMappingsResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedMappingsResponse {
        GetDefinedMappingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedMappingsResponse_SuccessResult>(
                    "success_result",
                    GetDefinedMappingsResponse::has_success_result,
                    GetDefinedMappingsResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedMappingsResponse_ErrorResult>(
                    "error_result",
                    GetDefinedMappingsResponse::has_error_result,
                    GetDefinedMappingsResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedMappingsResponse_FailureResult>(
                    "failure_result",
                    GetDefinedMappingsResponse::has_failure_result,
                    GetDefinedMappingsResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedMappingsResponse>(
                    "GetDefinedMappingsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedMappingsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedMappingsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedMappingsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedMappingsResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedMappingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedMappingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedMappingsResponse_SuccessResult {
    // message fields
    pub mappings: ::protobuf::RepeatedField<Mapping>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedMappingsResponse_SuccessResult {
    fn default() -> &'a GetDefinedMappingsResponse_SuccessResult {
        <GetDefinedMappingsResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedMappingsResponse_SuccessResult {
    pub fn new() -> GetDefinedMappingsResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // repeated .Mapping mappings = 1;


    pub fn get_mappings(&self) -> &[Mapping] {
        &self.mappings
    }
    pub fn clear_mappings(&mut self) {
        self.mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_mappings(&mut self, v: ::protobuf::RepeatedField<Mapping>) {
        self.mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mappings(&mut self) -> &mut ::protobuf::RepeatedField<Mapping> {
        &mut self.mappings
    }

    // Take field
    pub fn take_mappings(&mut self) -> ::protobuf::RepeatedField<Mapping> {
        ::std::mem::replace(&mut self.mappings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDefinedMappingsResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        for v in &self.mappings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mappings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mappings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedMappingsResponse_SuccessResult {
        GetDefinedMappingsResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mapping>>(
                    "mappings",
                    |m: &GetDefinedMappingsResponse_SuccessResult| { &m.mappings },
                    |m: &mut GetDefinedMappingsResponse_SuccessResult| { &mut m.mappings },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedMappingsResponse_SuccessResult>(
                    "GetDefinedMappingsResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedMappingsResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedMappingsResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedMappingsResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedMappingsResponse_SuccessResult {
    fn clear(&mut self) {
        self.mappings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedMappingsResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedMappingsResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedMappingsResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedMappingsResponse_ErrorResult {
    fn default() -> &'a GetDefinedMappingsResponse_ErrorResult {
        <GetDefinedMappingsResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedMappingsResponse_ErrorResult {
    pub fn new() -> GetDefinedMappingsResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDefinedMappingsResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedMappingsResponse_ErrorResult {
        GetDefinedMappingsResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDefinedMappingsResponse_ErrorResult| { &m.message },
                    |m: &mut GetDefinedMappingsResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedMappingsResponse_ErrorResult>(
                    "GetDefinedMappingsResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedMappingsResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedMappingsResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedMappingsResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedMappingsResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedMappingsResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedMappingsResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefinedMappingsResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefinedMappingsResponse_FailureResult {
    fn default() -> &'a GetDefinedMappingsResponse_FailureResult {
        <GetDefinedMappingsResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl GetDefinedMappingsResponse_FailureResult {
    pub fn new() -> GetDefinedMappingsResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for GetDefinedMappingsResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefinedMappingsResponse_FailureResult {
        GetDefinedMappingsResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &GetDefinedMappingsResponse_FailureResult| { &m.message },
                    |m: &mut GetDefinedMappingsResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefinedMappingsResponse_FailureResult>(
                    "GetDefinedMappingsResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDefinedMappingsResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<GetDefinedMappingsResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetDefinedMappingsResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for GetDefinedMappingsResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefinedMappingsResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefinedMappingsResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineMappingRequest {
    // message fields
    pub mapping: ::protobuf::SingularPtrField<Mapping>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineMappingRequest {
    fn default() -> &'a DefineMappingRequest {
        <DefineMappingRequest as ::protobuf::Message>::default_instance()
    }
}

impl DefineMappingRequest {
    pub fn new() -> DefineMappingRequest {
        ::std::default::Default::default()
    }

    // .Mapping mapping = 1;


    pub fn get_mapping(&self) -> &Mapping {
        self.mapping.as_ref().unwrap_or_else(|| Mapping::default_instance())
    }
    pub fn clear_mapping(&mut self) {
        self.mapping.clear();
    }

    pub fn has_mapping(&self) -> bool {
        self.mapping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapping(&mut self, v: Mapping) {
        self.mapping = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mapping(&mut self) -> &mut Mapping {
        if self.mapping.is_none() {
            self.mapping.set_default();
        }
        self.mapping.as_mut().unwrap()
    }

    // Take field
    pub fn take_mapping(&mut self) -> Mapping {
        self.mapping.take().unwrap_or_else(|| Mapping::new())
    }
}

impl ::protobuf::Message for DefineMappingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.mapping {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mapping)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mapping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mapping.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineMappingRequest {
        DefineMappingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mapping>>(
                    "mapping",
                    |m: &DefineMappingRequest| { &m.mapping },
                    |m: &mut DefineMappingRequest| { &mut m.mapping },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineMappingRequest>(
                    "DefineMappingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineMappingRequest {
        static mut instance: ::protobuf::lazy::Lazy<DefineMappingRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineMappingRequest::new)
        }
    }
}

impl ::protobuf::Clear for DefineMappingRequest {
    fn clear(&mut self) {
        self.mapping.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineMappingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineMappingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineMappingResponse {
    // message oneof groups
    pub result: ::std::option::Option<DefineMappingResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineMappingResponse {
    fn default() -> &'a DefineMappingResponse {
        <DefineMappingResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DefineMappingResponse_oneof_result {
    success_result(DefineMappingResponse_SuccessResult),
    error_result(DefineMappingResponse_ErrorResult),
    failure_result(DefineMappingResponse_FailureResult),
}

impl DefineMappingResponse {
    pub fn new() -> DefineMappingResponse {
        ::std::default::Default::default()
    }

    // .DefineMappingResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &DefineMappingResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(ref v)) => v,
            _ => DefineMappingResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: DefineMappingResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut DefineMappingResponse_SuccessResult {
        if let ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(DefineMappingResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> DefineMappingResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineMappingResponse_SuccessResult::new()
        }
    }

    // .DefineMappingResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &DefineMappingResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(ref v)) => v,
            _ => DefineMappingResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: DefineMappingResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut DefineMappingResponse_ErrorResult {
        if let ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(DefineMappingResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> DefineMappingResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineMappingResponse_ErrorResult::new()
        }
    }

    // .DefineMappingResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &DefineMappingResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(ref v)) => v,
            _ => DefineMappingResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: DefineMappingResponse_FailureResult) {
        self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut DefineMappingResponse_FailureResult {
        if let ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(DefineMappingResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> DefineMappingResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineMappingResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for DefineMappingResponse {
    fn is_initialized(&self) -> bool {
        if let Some(DefineMappingResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineMappingResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefineMappingResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DefineMappingResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineMappingResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineMappingResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefineMappingResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DefineMappingResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineMappingResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefineMappingResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineMappingResponse {
        DefineMappingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineMappingResponse_SuccessResult>(
                    "success_result",
                    DefineMappingResponse::has_success_result,
                    DefineMappingResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineMappingResponse_ErrorResult>(
                    "error_result",
                    DefineMappingResponse::has_error_result,
                    DefineMappingResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineMappingResponse_FailureResult>(
                    "failure_result",
                    DefineMappingResponse::has_failure_result,
                    DefineMappingResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineMappingResponse>(
                    "DefineMappingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineMappingResponse {
        static mut instance: ::protobuf::lazy::Lazy<DefineMappingResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineMappingResponse::new)
        }
    }
}

impl ::protobuf::Clear for DefineMappingResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineMappingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineMappingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineMappingResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineMappingResponse_SuccessResult {
    fn default() -> &'a DefineMappingResponse_SuccessResult {
        <DefineMappingResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineMappingResponse_SuccessResult {
    pub fn new() -> DefineMappingResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineMappingResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineMappingResponse_SuccessResult {
        DefineMappingResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineMappingResponse_SuccessResult| { &m.message },
                    |m: &mut DefineMappingResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineMappingResponse_SuccessResult>(
                    "DefineMappingResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineMappingResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineMappingResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineMappingResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineMappingResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineMappingResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineMappingResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineMappingResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineMappingResponse_ErrorResult {
    fn default() -> &'a DefineMappingResponse_ErrorResult {
        <DefineMappingResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineMappingResponse_ErrorResult {
    pub fn new() -> DefineMappingResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineMappingResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineMappingResponse_ErrorResult {
        DefineMappingResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineMappingResponse_ErrorResult| { &m.message },
                    |m: &mut DefineMappingResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineMappingResponse_ErrorResult>(
                    "DefineMappingResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineMappingResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineMappingResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineMappingResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineMappingResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineMappingResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineMappingResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefineMappingResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefineMappingResponse_FailureResult {
    fn default() -> &'a DefineMappingResponse_FailureResult {
        <DefineMappingResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl DefineMappingResponse_FailureResult {
    pub fn new() -> DefineMappingResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for DefineMappingResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefineMappingResponse_FailureResult {
        DefineMappingResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &DefineMappingResponse_FailureResult| { &m.message },
                    |m: &mut DefineMappingResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefineMappingResponse_FailureResult>(
                    "DefineMappingResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefineMappingResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<DefineMappingResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DefineMappingResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for DefineMappingResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefineMappingResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefineMappingResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeMappingRequest {
    // message fields
    pub key_chords: ::protobuf::RepeatedField<KeyChord>,
    pub action: ::protobuf::SingularPtrField<Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeMappingRequest {
    fn default() -> &'a ChangeMappingRequest {
        <ChangeMappingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChangeMappingRequest {
    pub fn new() -> ChangeMappingRequest {
        ::std::default::Default::default()
    }

    // repeated .KeyChord key_chords = 1;


    pub fn get_key_chords(&self) -> &[KeyChord] {
        &self.key_chords
    }
    pub fn clear_key_chords(&mut self) {
        self.key_chords.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_chords(&mut self, v: ::protobuf::RepeatedField<KeyChord>) {
        self.key_chords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_chords(&mut self) -> &mut ::protobuf::RepeatedField<KeyChord> {
        &mut self.key_chords
    }

    // Take field
    pub fn take_key_chords(&mut self) -> ::protobuf::RepeatedField<KeyChord> {
        ::std::mem::replace(&mut self.key_chords, ::protobuf::RepeatedField::new())
    }

    // .Action action = 2;


    pub fn get_action(&self) -> &Action {
        self.action.as_ref().unwrap_or_else(|| Action::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> Action {
        self.action.take().unwrap_or_else(|| Action::new())
    }
}

impl ::protobuf::Message for ChangeMappingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.key_chords {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.key_chords)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.key_chords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.key_chords {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeMappingRequest {
        ChangeMappingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyChord>>(
                    "key_chords",
                    |m: &ChangeMappingRequest| { &m.key_chords },
                    |m: &mut ChangeMappingRequest| { &mut m.key_chords },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                    "action",
                    |m: &ChangeMappingRequest| { &m.action },
                    |m: &mut ChangeMappingRequest| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeMappingRequest>(
                    "ChangeMappingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeMappingRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChangeMappingRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ChangeMappingRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChangeMappingRequest {
    fn clear(&mut self) {
        self.key_chords.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeMappingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeMappingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeMappingResponse {
    // message oneof groups
    pub result: ::std::option::Option<ChangeMappingResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeMappingResponse {
    fn default() -> &'a ChangeMappingResponse {
        <ChangeMappingResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChangeMappingResponse_oneof_result {
    success_result(ChangeMappingResponse_SuccessResult),
    error_result(ChangeMappingResponse_ErrorResult),
    failure_result(ChangeMappingResponse_FailureResult),
}

impl ChangeMappingResponse {
    pub fn new() -> ChangeMappingResponse {
        ::std::default::Default::default()
    }

    // .ChangeMappingResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &ChangeMappingResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(ref v)) => v,
            _ => ChangeMappingResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: ChangeMappingResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut ChangeMappingResponse_SuccessResult {
        if let ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(ChangeMappingResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> ChangeMappingResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeMappingResponse_SuccessResult::new()
        }
    }

    // .ChangeMappingResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &ChangeMappingResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(ref v)) => v,
            _ => ChangeMappingResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: ChangeMappingResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut ChangeMappingResponse_ErrorResult {
        if let ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(ChangeMappingResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> ChangeMappingResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeMappingResponse_ErrorResult::new()
        }
    }

    // .ChangeMappingResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &ChangeMappingResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(ref v)) => v,
            _ => ChangeMappingResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: ChangeMappingResponse_FailureResult) {
        self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut ChangeMappingResponse_FailureResult {
        if let ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(ChangeMappingResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> ChangeMappingResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeMappingResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for ChangeMappingResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ChangeMappingResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChangeMappingResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChangeMappingResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(ChangeMappingResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &ChangeMappingResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChangeMappingResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChangeMappingResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &ChangeMappingResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChangeMappingResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChangeMappingResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeMappingResponse {
        ChangeMappingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChangeMappingResponse_SuccessResult>(
                    "success_result",
                    ChangeMappingResponse::has_success_result,
                    ChangeMappingResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChangeMappingResponse_ErrorResult>(
                    "error_result",
                    ChangeMappingResponse::has_error_result,
                    ChangeMappingResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChangeMappingResponse_FailureResult>(
                    "failure_result",
                    ChangeMappingResponse::has_failure_result,
                    ChangeMappingResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeMappingResponse>(
                    "ChangeMappingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeMappingResponse {
        static mut instance: ::protobuf::lazy::Lazy<ChangeMappingResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ChangeMappingResponse::new)
        }
    }
}

impl ::protobuf::Clear for ChangeMappingResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeMappingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeMappingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeMappingResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeMappingResponse_SuccessResult {
    fn default() -> &'a ChangeMappingResponse_SuccessResult {
        <ChangeMappingResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl ChangeMappingResponse_SuccessResult {
    pub fn new() -> ChangeMappingResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ChangeMappingResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeMappingResponse_SuccessResult {
        ChangeMappingResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ChangeMappingResponse_SuccessResult| { &m.message },
                    |m: &mut ChangeMappingResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeMappingResponse_SuccessResult>(
                    "ChangeMappingResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeMappingResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<ChangeMappingResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ChangeMappingResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for ChangeMappingResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeMappingResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeMappingResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeMappingResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeMappingResponse_ErrorResult {
    fn default() -> &'a ChangeMappingResponse_ErrorResult {
        <ChangeMappingResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl ChangeMappingResponse_ErrorResult {
    pub fn new() -> ChangeMappingResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ChangeMappingResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeMappingResponse_ErrorResult {
        ChangeMappingResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ChangeMappingResponse_ErrorResult| { &m.message },
                    |m: &mut ChangeMappingResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeMappingResponse_ErrorResult>(
                    "ChangeMappingResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeMappingResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<ChangeMappingResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ChangeMappingResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for ChangeMappingResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeMappingResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeMappingResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeMappingResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeMappingResponse_FailureResult {
    fn default() -> &'a ChangeMappingResponse_FailureResult {
        <ChangeMappingResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl ChangeMappingResponse_FailureResult {
    pub fn new() -> ChangeMappingResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ChangeMappingResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeMappingResponse_FailureResult {
        ChangeMappingResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &ChangeMappingResponse_FailureResult| { &m.message },
                    |m: &mut ChangeMappingResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeMappingResponse_FailureResult>(
                    "ChangeMappingResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeMappingResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<ChangeMappingResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ChangeMappingResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for ChangeMappingResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeMappingResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeMappingResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveMappingRequest {
    // message fields
    pub key_chords: ::protobuf::RepeatedField<KeyChord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveMappingRequest {
    fn default() -> &'a RemoveMappingRequest {
        <RemoveMappingRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveMappingRequest {
    pub fn new() -> RemoveMappingRequest {
        ::std::default::Default::default()
    }

    // repeated .KeyChord key_chords = 1;


    pub fn get_key_chords(&self) -> &[KeyChord] {
        &self.key_chords
    }
    pub fn clear_key_chords(&mut self) {
        self.key_chords.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_chords(&mut self, v: ::protobuf::RepeatedField<KeyChord>) {
        self.key_chords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_chords(&mut self) -> &mut ::protobuf::RepeatedField<KeyChord> {
        &mut self.key_chords
    }

    // Take field
    pub fn take_key_chords(&mut self) -> ::protobuf::RepeatedField<KeyChord> {
        ::std::mem::replace(&mut self.key_chords, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RemoveMappingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.key_chords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.key_chords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.key_chords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.key_chords {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveMappingRequest {
        RemoveMappingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyChord>>(
                    "key_chords",
                    |m: &RemoveMappingRequest| { &m.key_chords },
                    |m: &mut RemoveMappingRequest| { &mut m.key_chords },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveMappingRequest>(
                    "RemoveMappingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveMappingRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveMappingRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveMappingRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveMappingRequest {
    fn clear(&mut self) {
        self.key_chords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveMappingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveMappingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveMappingResponse {
    // message oneof groups
    pub result: ::std::option::Option<RemoveMappingResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveMappingResponse {
    fn default() -> &'a RemoveMappingResponse {
        <RemoveMappingResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RemoveMappingResponse_oneof_result {
    success_result(RemoveMappingResponse_SuccessResult),
    error_result(RemoveMappingResponse_ErrorResult),
    failure_result(RemoveMappingResponse_FailureResult),
}

impl RemoveMappingResponse {
    pub fn new() -> RemoveMappingResponse {
        ::std::default::Default::default()
    }

    // .RemoveMappingResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &RemoveMappingResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(ref v)) => v,
            _ => RemoveMappingResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: RemoveMappingResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut RemoveMappingResponse_SuccessResult {
        if let ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(RemoveMappingResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> RemoveMappingResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveMappingResponse_SuccessResult::new()
        }
    }

    // .RemoveMappingResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &RemoveMappingResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(ref v)) => v,
            _ => RemoveMappingResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: RemoveMappingResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut RemoveMappingResponse_ErrorResult {
        if let ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(RemoveMappingResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> RemoveMappingResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveMappingResponse_ErrorResult::new()
        }
    }

    // .RemoveMappingResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &RemoveMappingResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(ref v)) => v,
            _ => RemoveMappingResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: RemoveMappingResponse_FailureResult) {
        self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut RemoveMappingResponse_FailureResult {
        if let ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(RemoveMappingResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> RemoveMappingResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveMappingResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for RemoveMappingResponse {
    fn is_initialized(&self) -> bool {
        if let Some(RemoveMappingResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveMappingResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RemoveMappingResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(RemoveMappingResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveMappingResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveMappingResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RemoveMappingResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &RemoveMappingResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveMappingResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RemoveMappingResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveMappingResponse {
        RemoveMappingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveMappingResponse_SuccessResult>(
                    "success_result",
                    RemoveMappingResponse::has_success_result,
                    RemoveMappingResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveMappingResponse_ErrorResult>(
                    "error_result",
                    RemoveMappingResponse::has_error_result,
                    RemoveMappingResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveMappingResponse_FailureResult>(
                    "failure_result",
                    RemoveMappingResponse::has_failure_result,
                    RemoveMappingResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveMappingResponse>(
                    "RemoveMappingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveMappingResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveMappingResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveMappingResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveMappingResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveMappingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveMappingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveMappingResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveMappingResponse_SuccessResult {
    fn default() -> &'a RemoveMappingResponse_SuccessResult {
        <RemoveMappingResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveMappingResponse_SuccessResult {
    pub fn new() -> RemoveMappingResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveMappingResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveMappingResponse_SuccessResult {
        RemoveMappingResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveMappingResponse_SuccessResult| { &m.message },
                    |m: &mut RemoveMappingResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveMappingResponse_SuccessResult>(
                    "RemoveMappingResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveMappingResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveMappingResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveMappingResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveMappingResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveMappingResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveMappingResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveMappingResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveMappingResponse_ErrorResult {
    fn default() -> &'a RemoveMappingResponse_ErrorResult {
        <RemoveMappingResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveMappingResponse_ErrorResult {
    pub fn new() -> RemoveMappingResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveMappingResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveMappingResponse_ErrorResult {
        RemoveMappingResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveMappingResponse_ErrorResult| { &m.message },
                    |m: &mut RemoveMappingResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveMappingResponse_ErrorResult>(
                    "RemoveMappingResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveMappingResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveMappingResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveMappingResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveMappingResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveMappingResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveMappingResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveMappingResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveMappingResponse_FailureResult {
    fn default() -> &'a RemoveMappingResponse_FailureResult {
        <RemoveMappingResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl RemoveMappingResponse_FailureResult {
    pub fn new() -> RemoveMappingResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for RemoveMappingResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveMappingResponse_FailureResult {
        RemoveMappingResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &RemoveMappingResponse_FailureResult| { &m.message },
                    |m: &mut RemoveMappingResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveMappingResponse_FailureResult>(
                    "RemoveMappingResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveMappingResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<RemoveMappingResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RemoveMappingResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for RemoveMappingResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveMappingResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveMappingResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsListeningRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsListeningRequest {
    fn default() -> &'a IsListeningRequest {
        <IsListeningRequest as ::protobuf::Message>::default_instance()
    }
}

impl IsListeningRequest {
    pub fn new() -> IsListeningRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsListeningRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsListeningRequest {
        IsListeningRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsListeningRequest>(
                    "IsListeningRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsListeningRequest {
        static mut instance: ::protobuf::lazy::Lazy<IsListeningRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IsListeningRequest::new)
        }
    }
}

impl ::protobuf::Clear for IsListeningRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsListeningRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsListeningRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsListeningResponse {
    // message oneof groups
    pub result: ::std::option::Option<IsListeningResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsListeningResponse {
    fn default() -> &'a IsListeningResponse {
        <IsListeningResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum IsListeningResponse_oneof_result {
    success_result(IsListeningResponse_SuccessResult),
    error_result(IsListeningResponse_ErrorResult),
    failure_result(IsListeningResponse_FailureResult),
}

impl IsListeningResponse {
    pub fn new() -> IsListeningResponse {
        ::std::default::Default::default()
    }

    // .IsListeningResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &IsListeningResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(ref v)) => v,
            _ => IsListeningResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: IsListeningResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut IsListeningResponse_SuccessResult {
        if let ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(IsListeningResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> IsListeningResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            IsListeningResponse_SuccessResult::new()
        }
    }

    // .IsListeningResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &IsListeningResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(ref v)) => v,
            _ => IsListeningResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: IsListeningResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut IsListeningResponse_ErrorResult {
        if let ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(IsListeningResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> IsListeningResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            IsListeningResponse_ErrorResult::new()
        }
    }

    // .IsListeningResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &IsListeningResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(ref v)) => v,
            _ => IsListeningResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: IsListeningResponse_FailureResult) {
        self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut IsListeningResponse_FailureResult {
        if let ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(IsListeningResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> IsListeningResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            IsListeningResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for IsListeningResponse {
    fn is_initialized(&self) -> bool {
        if let Some(IsListeningResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(IsListeningResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(IsListeningResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(IsListeningResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &IsListeningResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &IsListeningResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &IsListeningResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &IsListeningResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &IsListeningResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &IsListeningResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsListeningResponse {
        IsListeningResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IsListeningResponse_SuccessResult>(
                    "success_result",
                    IsListeningResponse::has_success_result,
                    IsListeningResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IsListeningResponse_ErrorResult>(
                    "error_result",
                    IsListeningResponse::has_error_result,
                    IsListeningResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IsListeningResponse_FailureResult>(
                    "failure_result",
                    IsListeningResponse::has_failure_result,
                    IsListeningResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsListeningResponse>(
                    "IsListeningResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsListeningResponse {
        static mut instance: ::protobuf::lazy::Lazy<IsListeningResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IsListeningResponse::new)
        }
    }
}

impl ::protobuf::Clear for IsListeningResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsListeningResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsListeningResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsListeningResponse_SuccessResult {
    // message fields
    pub is_listening: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsListeningResponse_SuccessResult {
    fn default() -> &'a IsListeningResponse_SuccessResult {
        <IsListeningResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl IsListeningResponse_SuccessResult {
    pub fn new() -> IsListeningResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // bool is_listening = 1;


    pub fn get_is_listening(&self) -> bool {
        self.is_listening
    }
    pub fn clear_is_listening(&mut self) {
        self.is_listening = false;
    }

    // Param is passed by value, moved
    pub fn set_is_listening(&mut self, v: bool) {
        self.is_listening = v;
    }
}

impl ::protobuf::Message for IsListeningResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_listening = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_listening != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_listening != false {
            os.write_bool(1, self.is_listening)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsListeningResponse_SuccessResult {
        IsListeningResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_listening",
                    |m: &IsListeningResponse_SuccessResult| { &m.is_listening },
                    |m: &mut IsListeningResponse_SuccessResult| { &mut m.is_listening },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsListeningResponse_SuccessResult>(
                    "IsListeningResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsListeningResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<IsListeningResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IsListeningResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for IsListeningResponse_SuccessResult {
    fn clear(&mut self) {
        self.is_listening = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsListeningResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsListeningResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsListeningResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsListeningResponse_ErrorResult {
    fn default() -> &'a IsListeningResponse_ErrorResult {
        <IsListeningResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl IsListeningResponse_ErrorResult {
    pub fn new() -> IsListeningResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for IsListeningResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsListeningResponse_ErrorResult {
        IsListeningResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &IsListeningResponse_ErrorResult| { &m.message },
                    |m: &mut IsListeningResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsListeningResponse_ErrorResult>(
                    "IsListeningResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsListeningResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<IsListeningResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IsListeningResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for IsListeningResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsListeningResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsListeningResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsListeningResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsListeningResponse_FailureResult {
    fn default() -> &'a IsListeningResponse_FailureResult {
        <IsListeningResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl IsListeningResponse_FailureResult {
    pub fn new() -> IsListeningResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for IsListeningResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsListeningResponse_FailureResult {
        IsListeningResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &IsListeningResponse_FailureResult| { &m.message },
                    |m: &mut IsListeningResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsListeningResponse_FailureResult>(
                    "IsListeningResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsListeningResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<IsListeningResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IsListeningResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for IsListeningResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsListeningResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsListeningResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartListeningRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartListeningRequest {
    fn default() -> &'a StartListeningRequest {
        <StartListeningRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartListeningRequest {
    pub fn new() -> StartListeningRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartListeningRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartListeningRequest {
        StartListeningRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartListeningRequest>(
                    "StartListeningRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartListeningRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartListeningRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartListeningRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartListeningRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartListeningRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartListeningRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartListeningResponse {
    // message oneof groups
    pub result: ::std::option::Option<StartListeningResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartListeningResponse {
    fn default() -> &'a StartListeningResponse {
        <StartListeningResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StartListeningResponse_oneof_result {
    success_result(StartListeningResponse_SuccessResult),
    error_result(StartListeningResponse_ErrorResult),
    failure_result(StartListeningResponse_FailureResult),
}

impl StartListeningResponse {
    pub fn new() -> StartListeningResponse {
        ::std::default::Default::default()
    }

    // .StartListeningResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &StartListeningResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(ref v)) => v,
            _ => StartListeningResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: StartListeningResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut StartListeningResponse_SuccessResult {
        if let ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(StartListeningResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> StartListeningResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            StartListeningResponse_SuccessResult::new()
        }
    }

    // .StartListeningResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &StartListeningResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(ref v)) => v,
            _ => StartListeningResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: StartListeningResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut StartListeningResponse_ErrorResult {
        if let ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(StartListeningResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> StartListeningResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            StartListeningResponse_ErrorResult::new()
        }
    }

    // .StartListeningResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &StartListeningResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(ref v)) => v,
            _ => StartListeningResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: StartListeningResponse_FailureResult) {
        self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut StartListeningResponse_FailureResult {
        if let ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(StartListeningResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> StartListeningResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            StartListeningResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for StartListeningResponse {
    fn is_initialized(&self) -> bool {
        if let Some(StartListeningResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StartListeningResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StartListeningResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(StartListeningResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &StartListeningResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StartListeningResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StartListeningResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &StartListeningResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StartListeningResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StartListeningResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartListeningResponse {
        StartListeningResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartListeningResponse_SuccessResult>(
                    "success_result",
                    StartListeningResponse::has_success_result,
                    StartListeningResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartListeningResponse_ErrorResult>(
                    "error_result",
                    StartListeningResponse::has_error_result,
                    StartListeningResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartListeningResponse_FailureResult>(
                    "failure_result",
                    StartListeningResponse::has_failure_result,
                    StartListeningResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartListeningResponse>(
                    "StartListeningResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartListeningResponse {
        static mut instance: ::protobuf::lazy::Lazy<StartListeningResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartListeningResponse::new)
        }
    }
}

impl ::protobuf::Clear for StartListeningResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartListeningResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartListeningResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartListeningResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartListeningResponse_SuccessResult {
    fn default() -> &'a StartListeningResponse_SuccessResult {
        <StartListeningResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl StartListeningResponse_SuccessResult {
    pub fn new() -> StartListeningResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for StartListeningResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartListeningResponse_SuccessResult {
        StartListeningResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &StartListeningResponse_SuccessResult| { &m.message },
                    |m: &mut StartListeningResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartListeningResponse_SuccessResult>(
                    "StartListeningResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartListeningResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<StartListeningResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartListeningResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for StartListeningResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartListeningResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartListeningResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartListeningResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartListeningResponse_ErrorResult {
    fn default() -> &'a StartListeningResponse_ErrorResult {
        <StartListeningResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl StartListeningResponse_ErrorResult {
    pub fn new() -> StartListeningResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for StartListeningResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartListeningResponse_ErrorResult {
        StartListeningResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &StartListeningResponse_ErrorResult| { &m.message },
                    |m: &mut StartListeningResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartListeningResponse_ErrorResult>(
                    "StartListeningResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartListeningResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<StartListeningResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartListeningResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for StartListeningResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartListeningResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartListeningResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartListeningResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartListeningResponse_FailureResult {
    fn default() -> &'a StartListeningResponse_FailureResult {
        <StartListeningResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl StartListeningResponse_FailureResult {
    pub fn new() -> StartListeningResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for StartListeningResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartListeningResponse_FailureResult {
        StartListeningResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &StartListeningResponse_FailureResult| { &m.message },
                    |m: &mut StartListeningResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartListeningResponse_FailureResult>(
                    "StartListeningResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartListeningResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<StartListeningResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StartListeningResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for StartListeningResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartListeningResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartListeningResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopListeningRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopListeningRequest {
    fn default() -> &'a StopListeningRequest {
        <StopListeningRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopListeningRequest {
    pub fn new() -> StopListeningRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopListeningRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopListeningRequest {
        StopListeningRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopListeningRequest>(
                    "StopListeningRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopListeningRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopListeningRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StopListeningRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopListeningRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopListeningRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopListeningRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopListeningResponse {
    // message oneof groups
    pub result: ::std::option::Option<StopListeningResponse_oneof_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopListeningResponse {
    fn default() -> &'a StopListeningResponse {
        <StopListeningResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StopListeningResponse_oneof_result {
    success_result(StopListeningResponse_SuccessResult),
    error_result(StopListeningResponse_ErrorResult),
    failure_result(StopListeningResponse_FailureResult),
}

impl StopListeningResponse {
    pub fn new() -> StopListeningResponse {
        ::std::default::Default::default()
    }

    // .StopListeningResponse.SuccessResult success_result = 1;


    pub fn get_success_result(&self) -> &StopListeningResponse_SuccessResult {
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(ref v)) => v,
            _ => StopListeningResponse_SuccessResult::default_instance(),
        }
    }
    pub fn clear_success_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_success_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success_result(&mut self, v: StopListeningResponse_SuccessResult) {
        self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success_result(&mut self) -> &mut StopListeningResponse_SuccessResult {
        if let ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(StopListeningResponse_SuccessResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success_result(&mut self) -> StopListeningResponse_SuccessResult {
        if self.has_success_result() {
            match self.result.take() {
                ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(v)) => v,
                _ => panic!(),
            }
        } else {
            StopListeningResponse_SuccessResult::new()
        }
    }

    // .StopListeningResponse.ErrorResult error_result = 2;


    pub fn get_error_result(&self) -> &StopListeningResponse_ErrorResult {
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(ref v)) => v,
            _ => StopListeningResponse_ErrorResult::default_instance(),
        }
    }
    pub fn clear_error_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_result(&mut self, v: StopListeningResponse_ErrorResult) {
        self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_result(&mut self) -> &mut StopListeningResponse_ErrorResult {
        if let ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(StopListeningResponse_ErrorResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_result(&mut self) -> StopListeningResponse_ErrorResult {
        if self.has_error_result() {
            match self.result.take() {
                ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(v)) => v,
                _ => panic!(),
            }
        } else {
            StopListeningResponse_ErrorResult::new()
        }
    }

    // .StopListeningResponse.FailureResult failure_result = 3;


    pub fn get_failure_result(&self) -> &StopListeningResponse_FailureResult {
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(ref v)) => v,
            _ => StopListeningResponse_FailureResult::default_instance(),
        }
    }
    pub fn clear_failure_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_failure_result(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_failure_result(&mut self, v: StopListeningResponse_FailureResult) {
        self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(v))
    }

    // Mutable pointer to the field.
    pub fn mut_failure_result(&mut self) -> &mut StopListeningResponse_FailureResult {
        if let ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(StopListeningResponse_FailureResult::new()));
        }
        match self.result {
            ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_failure_result(&mut self) -> StopListeningResponse_FailureResult {
        if self.has_failure_result() {
            match self.result.take() {
                ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(v)) => v,
                _ => panic!(),
            }
        } else {
            StopListeningResponse_FailureResult::new()
        }
    }
}

impl ::protobuf::Message for StopListeningResponse {
    fn is_initialized(&self) -> bool {
        if let Some(StopListeningResponse_oneof_result::success_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StopListeningResponse_oneof_result::error_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StopListeningResponse_oneof_result::failure_result(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::success_result(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::error_result(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(StopListeningResponse_oneof_result::failure_result(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &StopListeningResponse_oneof_result::success_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StopListeningResponse_oneof_result::error_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StopListeningResponse_oneof_result::failure_result(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &StopListeningResponse_oneof_result::success_result(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StopListeningResponse_oneof_result::error_result(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StopListeningResponse_oneof_result::failure_result(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopListeningResponse {
        StopListeningResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StopListeningResponse_SuccessResult>(
                    "success_result",
                    StopListeningResponse::has_success_result,
                    StopListeningResponse::get_success_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StopListeningResponse_ErrorResult>(
                    "error_result",
                    StopListeningResponse::has_error_result,
                    StopListeningResponse::get_error_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StopListeningResponse_FailureResult>(
                    "failure_result",
                    StopListeningResponse::has_failure_result,
                    StopListeningResponse::get_failure_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopListeningResponse>(
                    "StopListeningResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopListeningResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopListeningResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StopListeningResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopListeningResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopListeningResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopListeningResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopListeningResponse_SuccessResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopListeningResponse_SuccessResult {
    fn default() -> &'a StopListeningResponse_SuccessResult {
        <StopListeningResponse_SuccessResult as ::protobuf::Message>::default_instance()
    }
}

impl StopListeningResponse_SuccessResult {
    pub fn new() -> StopListeningResponse_SuccessResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for StopListeningResponse_SuccessResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopListeningResponse_SuccessResult {
        StopListeningResponse_SuccessResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &StopListeningResponse_SuccessResult| { &m.message },
                    |m: &mut StopListeningResponse_SuccessResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopListeningResponse_SuccessResult>(
                    "StopListeningResponse.SuccessResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopListeningResponse_SuccessResult {
        static mut instance: ::protobuf::lazy::Lazy<StopListeningResponse_SuccessResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StopListeningResponse_SuccessResult::new)
        }
    }
}

impl ::protobuf::Clear for StopListeningResponse_SuccessResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopListeningResponse_SuccessResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopListeningResponse_SuccessResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopListeningResponse_ErrorResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopListeningResponse_ErrorResult {
    fn default() -> &'a StopListeningResponse_ErrorResult {
        <StopListeningResponse_ErrorResult as ::protobuf::Message>::default_instance()
    }
}

impl StopListeningResponse_ErrorResult {
    pub fn new() -> StopListeningResponse_ErrorResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for StopListeningResponse_ErrorResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopListeningResponse_ErrorResult {
        StopListeningResponse_ErrorResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &StopListeningResponse_ErrorResult| { &m.message },
                    |m: &mut StopListeningResponse_ErrorResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopListeningResponse_ErrorResult>(
                    "StopListeningResponse.ErrorResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopListeningResponse_ErrorResult {
        static mut instance: ::protobuf::lazy::Lazy<StopListeningResponse_ErrorResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StopListeningResponse_ErrorResult::new)
        }
    }
}

impl ::protobuf::Clear for StopListeningResponse_ErrorResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopListeningResponse_ErrorResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopListeningResponse_ErrorResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopListeningResponse_FailureResult {
    // message fields
    pub message: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopListeningResponse_FailureResult {
    fn default() -> &'a StopListeningResponse_FailureResult {
        <StopListeningResponse_FailureResult as ::protobuf::Message>::default_instance()
    }
}

impl StopListeningResponse_FailureResult {
    pub fn new() -> StopListeningResponse_FailureResult {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::Chars) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::protobuf::Chars {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.message, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for StopListeningResponse_FailureResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopListeningResponse_FailureResult {
        StopListeningResponse_FailureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "message",
                    |m: &StopListeningResponse_FailureResult| { &m.message },
                    |m: &mut StopListeningResponse_FailureResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopListeningResponse_FailureResult>(
                    "StopListeningResponse.FailureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopListeningResponse_FailureResult {
        static mut instance: ::protobuf::lazy::Lazy<StopListeningResponse_FailureResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StopListeningResponse_FailureResult::new)
        }
    }
}

impl ::protobuf::Clear for StopListeningResponse_FailureResult {
    fn clear(&mut self) {
        ::protobuf::Clear::clear(&mut self.message);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopListeningResponse_FailureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopListeningResponse_FailureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message oneof groups
    pub request: ::std::option::Option<Request_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Request_oneof_request {
    handshake_request(HandshakeRequest),
    get_devices_request(GetDevicesRequest),
    execute_code_request(ExecuteCodeRequest),
    define_device_request(DefineDeviceRequest),
    remove_device_by_path_request(RemoveDeviceByPathRequest),
    remove_device_by_name_request(RemoveDeviceByNameRequest),
    remove_device_by_id_request(RemoveDeviceByIdRequest),
    get_defined_modifiers_request(GetDefinedModifiersRequest),
    define_modifier_request(DefineModifierRequest),
    remove_modifier_request(RemoveModifierRequest),
    get_defined_actions_request(GetDefinedActionsRequest),
    define_action_request(DefineActionRequest),
    remove_action_request(RemoveActionRequest),
    get_defined_mappings_request(GetDefinedMappingsRequest),
    define_mapping_request(DefineMappingRequest),
    change_mapping_request(ChangeMappingRequest),
    remove_mapping_request(RemoveMappingRequest),
    is_listening_request(IsListeningRequest),
    start_listening_request(StartListeningRequest),
    stop_listening_request(StopListeningRequest),
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // .HandshakeRequest handshake_request = 1;


    pub fn get_handshake_request(&self) -> &HandshakeRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::handshake_request(ref v)) => v,
            _ => HandshakeRequest::default_instance(),
        }
    }
    pub fn clear_handshake_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_handshake_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::handshake_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake_request(&mut self, v: HandshakeRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::handshake_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake_request(&mut self) -> &mut HandshakeRequest {
        if let ::std::option::Option::Some(Request_oneof_request::handshake_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::handshake_request(HandshakeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::handshake_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake_request(&mut self) -> HandshakeRequest {
        if self.has_handshake_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::handshake_request(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeRequest::new()
        }
    }

    // .GetDevicesRequest get_devices_request = 2;


    pub fn get_get_devices_request(&self) -> &GetDevicesRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_devices_request(ref v)) => v,
            _ => GetDevicesRequest::default_instance(),
        }
    }
    pub fn clear_get_devices_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_devices_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_devices_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_devices_request(&mut self, v: GetDevicesRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::get_devices_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_devices_request(&mut self) -> &mut GetDevicesRequest {
        if let ::std::option::Option::Some(Request_oneof_request::get_devices_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::get_devices_request(GetDevicesRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_devices_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_devices_request(&mut self) -> GetDevicesRequest {
        if self.has_get_devices_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::get_devices_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesRequest::new()
        }
    }

    // .ExecuteCodeRequest execute_code_request = 3;


    pub fn get_execute_code_request(&self) -> &ExecuteCodeRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::execute_code_request(ref v)) => v,
            _ => ExecuteCodeRequest::default_instance(),
        }
    }
    pub fn clear_execute_code_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_execute_code_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::execute_code_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execute_code_request(&mut self, v: ExecuteCodeRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::execute_code_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execute_code_request(&mut self) -> &mut ExecuteCodeRequest {
        if let ::std::option::Option::Some(Request_oneof_request::execute_code_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::execute_code_request(ExecuteCodeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::execute_code_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execute_code_request(&mut self) -> ExecuteCodeRequest {
        if self.has_execute_code_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::execute_code_request(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeRequest::new()
        }
    }

    // .DefineDeviceRequest define_device_request = 4;


    pub fn get_define_device_request(&self) -> &DefineDeviceRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_device_request(ref v)) => v,
            _ => DefineDeviceRequest::default_instance(),
        }
    }
    pub fn clear_define_device_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_define_device_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_device_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_device_request(&mut self, v: DefineDeviceRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::define_device_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_device_request(&mut self) -> &mut DefineDeviceRequest {
        if let ::std::option::Option::Some(Request_oneof_request::define_device_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::define_device_request(DefineDeviceRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_device_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_device_request(&mut self) -> DefineDeviceRequest {
        if self.has_define_device_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::define_device_request(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineDeviceRequest::new()
        }
    }

    // .RemoveDeviceByPathRequest remove_device_by_path_request = 5;


    pub fn get_remove_device_by_path_request(&self) -> &RemoveDeviceByPathRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(ref v)) => v,
            _ => RemoveDeviceByPathRequest::default_instance(),
        }
    }
    pub fn clear_remove_device_by_path_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_device_by_path_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_device_by_path_request(&mut self, v: RemoveDeviceByPathRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_device_by_path_request(&mut self) -> &mut RemoveDeviceByPathRequest {
        if let ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(RemoveDeviceByPathRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_device_by_path_request(&mut self) -> RemoveDeviceByPathRequest {
        if self.has_remove_device_by_path_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByPathRequest::new()
        }
    }

    // .RemoveDeviceByNameRequest remove_device_by_name_request = 6;


    pub fn get_remove_device_by_name_request(&self) -> &RemoveDeviceByNameRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(ref v)) => v,
            _ => RemoveDeviceByNameRequest::default_instance(),
        }
    }
    pub fn clear_remove_device_by_name_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_device_by_name_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_device_by_name_request(&mut self, v: RemoveDeviceByNameRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_device_by_name_request(&mut self) -> &mut RemoveDeviceByNameRequest {
        if let ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(RemoveDeviceByNameRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_device_by_name_request(&mut self) -> RemoveDeviceByNameRequest {
        if self.has_remove_device_by_name_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByNameRequest::new()
        }
    }

    // .RemoveDeviceByIdRequest remove_device_by_id_request = 7;


    pub fn get_remove_device_by_id_request(&self) -> &RemoveDeviceByIdRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(ref v)) => v,
            _ => RemoveDeviceByIdRequest::default_instance(),
        }
    }
    pub fn clear_remove_device_by_id_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_device_by_id_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_device_by_id_request(&mut self, v: RemoveDeviceByIdRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_device_by_id_request(&mut self) -> &mut RemoveDeviceByIdRequest {
        if let ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(RemoveDeviceByIdRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_device_by_id_request(&mut self) -> RemoveDeviceByIdRequest {
        if self.has_remove_device_by_id_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByIdRequest::new()
        }
    }

    // .GetDefinedModifiersRequest get_defined_modifiers_request = 8;


    pub fn get_get_defined_modifiers_request(&self) -> &GetDefinedModifiersRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(ref v)) => v,
            _ => GetDefinedModifiersRequest::default_instance(),
        }
    }
    pub fn clear_get_defined_modifiers_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_defined_modifiers_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_defined_modifiers_request(&mut self, v: GetDefinedModifiersRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_defined_modifiers_request(&mut self) -> &mut GetDefinedModifiersRequest {
        if let ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(GetDefinedModifiersRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_defined_modifiers_request(&mut self) -> GetDefinedModifiersRequest {
        if self.has_get_defined_modifiers_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedModifiersRequest::new()
        }
    }

    // .DefineModifierRequest define_modifier_request = 9;


    pub fn get_define_modifier_request(&self) -> &DefineModifierRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_modifier_request(ref v)) => v,
            _ => DefineModifierRequest::default_instance(),
        }
    }
    pub fn clear_define_modifier_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_define_modifier_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_modifier_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_modifier_request(&mut self, v: DefineModifierRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::define_modifier_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_modifier_request(&mut self) -> &mut DefineModifierRequest {
        if let ::std::option::Option::Some(Request_oneof_request::define_modifier_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::define_modifier_request(DefineModifierRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_modifier_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_modifier_request(&mut self) -> DefineModifierRequest {
        if self.has_define_modifier_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::define_modifier_request(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineModifierRequest::new()
        }
    }

    // .RemoveModifierRequest remove_modifier_request = 10;


    pub fn get_remove_modifier_request(&self) -> &RemoveModifierRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(ref v)) => v,
            _ => RemoveModifierRequest::default_instance(),
        }
    }
    pub fn clear_remove_modifier_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_modifier_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_modifier_request(&mut self, v: RemoveModifierRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_modifier_request(&mut self) -> &mut RemoveModifierRequest {
        if let ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(RemoveModifierRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_modifier_request(&mut self) -> RemoveModifierRequest {
        if self.has_remove_modifier_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveModifierRequest::new()
        }
    }

    // .GetDefinedActionsRequest get_defined_actions_request = 11;


    pub fn get_get_defined_actions_request(&self) -> &GetDefinedActionsRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(ref v)) => v,
            _ => GetDefinedActionsRequest::default_instance(),
        }
    }
    pub fn clear_get_defined_actions_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_defined_actions_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_defined_actions_request(&mut self, v: GetDefinedActionsRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_defined_actions_request(&mut self) -> &mut GetDefinedActionsRequest {
        if let ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(GetDefinedActionsRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_defined_actions_request(&mut self) -> GetDefinedActionsRequest {
        if self.has_get_defined_actions_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedActionsRequest::new()
        }
    }

    // .DefineActionRequest define_action_request = 12;


    pub fn get_define_action_request(&self) -> &DefineActionRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_action_request(ref v)) => v,
            _ => DefineActionRequest::default_instance(),
        }
    }
    pub fn clear_define_action_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_define_action_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_action_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_action_request(&mut self, v: DefineActionRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::define_action_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_action_request(&mut self) -> &mut DefineActionRequest {
        if let ::std::option::Option::Some(Request_oneof_request::define_action_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::define_action_request(DefineActionRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_action_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_action_request(&mut self) -> DefineActionRequest {
        if self.has_define_action_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::define_action_request(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineActionRequest::new()
        }
    }

    // .RemoveActionRequest remove_action_request = 13;


    pub fn get_remove_action_request(&self) -> &RemoveActionRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_action_request(ref v)) => v,
            _ => RemoveActionRequest::default_instance(),
        }
    }
    pub fn clear_remove_action_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_action_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_action_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_action_request(&mut self, v: RemoveActionRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::remove_action_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_action_request(&mut self) -> &mut RemoveActionRequest {
        if let ::std::option::Option::Some(Request_oneof_request::remove_action_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::remove_action_request(RemoveActionRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_action_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_action_request(&mut self) -> RemoveActionRequest {
        if self.has_remove_action_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::remove_action_request(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveActionRequest::new()
        }
    }

    // .GetDefinedMappingsRequest get_defined_mappings_request = 14;


    pub fn get_get_defined_mappings_request(&self) -> &GetDefinedMappingsRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(ref v)) => v,
            _ => GetDefinedMappingsRequest::default_instance(),
        }
    }
    pub fn clear_get_defined_mappings_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_defined_mappings_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_defined_mappings_request(&mut self, v: GetDefinedMappingsRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_defined_mappings_request(&mut self) -> &mut GetDefinedMappingsRequest {
        if let ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(GetDefinedMappingsRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_defined_mappings_request(&mut self) -> GetDefinedMappingsRequest {
        if self.has_get_defined_mappings_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedMappingsRequest::new()
        }
    }

    // .DefineMappingRequest define_mapping_request = 15;


    pub fn get_define_mapping_request(&self) -> &DefineMappingRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_mapping_request(ref v)) => v,
            _ => DefineMappingRequest::default_instance(),
        }
    }
    pub fn clear_define_mapping_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_define_mapping_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_mapping_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_mapping_request(&mut self, v: DefineMappingRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::define_mapping_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_mapping_request(&mut self) -> &mut DefineMappingRequest {
        if let ::std::option::Option::Some(Request_oneof_request::define_mapping_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::define_mapping_request(DefineMappingRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::define_mapping_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_mapping_request(&mut self) -> DefineMappingRequest {
        if self.has_define_mapping_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::define_mapping_request(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineMappingRequest::new()
        }
    }

    // .ChangeMappingRequest change_mapping_request = 16;


    pub fn get_change_mapping_request(&self) -> &ChangeMappingRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::change_mapping_request(ref v)) => v,
            _ => ChangeMappingRequest::default_instance(),
        }
    }
    pub fn clear_change_mapping_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_change_mapping_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::change_mapping_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_change_mapping_request(&mut self, v: ChangeMappingRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::change_mapping_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_change_mapping_request(&mut self) -> &mut ChangeMappingRequest {
        if let ::std::option::Option::Some(Request_oneof_request::change_mapping_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::change_mapping_request(ChangeMappingRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::change_mapping_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_change_mapping_request(&mut self) -> ChangeMappingRequest {
        if self.has_change_mapping_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::change_mapping_request(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeMappingRequest::new()
        }
    }

    // .RemoveMappingRequest remove_mapping_request = 17;


    pub fn get_remove_mapping_request(&self) -> &RemoveMappingRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(ref v)) => v,
            _ => RemoveMappingRequest::default_instance(),
        }
    }
    pub fn clear_remove_mapping_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_remove_mapping_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_mapping_request(&mut self, v: RemoveMappingRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_mapping_request(&mut self) -> &mut RemoveMappingRequest {
        if let ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(RemoveMappingRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_mapping_request(&mut self) -> RemoveMappingRequest {
        if self.has_remove_mapping_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveMappingRequest::new()
        }
    }

    // .IsListeningRequest is_listening_request = 18;


    pub fn get_is_listening_request(&self) -> &IsListeningRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::is_listening_request(ref v)) => v,
            _ => IsListeningRequest::default_instance(),
        }
    }
    pub fn clear_is_listening_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_is_listening_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::is_listening_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_is_listening_request(&mut self, v: IsListeningRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::is_listening_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_is_listening_request(&mut self) -> &mut IsListeningRequest {
        if let ::std::option::Option::Some(Request_oneof_request::is_listening_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::is_listening_request(IsListeningRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::is_listening_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_is_listening_request(&mut self) -> IsListeningRequest {
        if self.has_is_listening_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::is_listening_request(v)) => v,
                _ => panic!(),
            }
        } else {
            IsListeningRequest::new()
        }
    }

    // .StartListeningRequest start_listening_request = 19;


    pub fn get_start_listening_request(&self) -> &StartListeningRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::start_listening_request(ref v)) => v,
            _ => StartListeningRequest::default_instance(),
        }
    }
    pub fn clear_start_listening_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_start_listening_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::start_listening_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_listening_request(&mut self, v: StartListeningRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::start_listening_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_listening_request(&mut self) -> &mut StartListeningRequest {
        if let ::std::option::Option::Some(Request_oneof_request::start_listening_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::start_listening_request(StartListeningRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::start_listening_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_listening_request(&mut self) -> StartListeningRequest {
        if self.has_start_listening_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::start_listening_request(v)) => v,
                _ => panic!(),
            }
        } else {
            StartListeningRequest::new()
        }
    }

    // .StopListeningRequest stop_listening_request = 20;


    pub fn get_stop_listening_request(&self) -> &StopListeningRequest {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::stop_listening_request(ref v)) => v,
            _ => StopListeningRequest::default_instance(),
        }
    }
    pub fn clear_stop_listening_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_stop_listening_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::stop_listening_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_listening_request(&mut self, v: StopListeningRequest) {
        self.request = ::std::option::Option::Some(Request_oneof_request::stop_listening_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_listening_request(&mut self) -> &mut StopListeningRequest {
        if let ::std::option::Option::Some(Request_oneof_request::stop_listening_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::stop_listening_request(StopListeningRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::stop_listening_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_listening_request(&mut self) -> StopListeningRequest {
        if self.has_stop_listening_request() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::stop_listening_request(v)) => v,
                _ => panic!(),
            }
        } else {
            StopListeningRequest::new()
        }
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        if let Some(Request_oneof_request::handshake_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::get_devices_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::execute_code_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::define_device_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::remove_device_by_path_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::remove_device_by_name_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::remove_device_by_id_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::get_defined_modifiers_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::define_modifier_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::remove_modifier_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::get_defined_actions_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::define_action_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::remove_action_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::get_defined_mappings_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::define_mapping_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::change_mapping_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::remove_mapping_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::is_listening_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::start_listening_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::stop_listening_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::handshake_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::get_devices_request(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::execute_code_request(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::define_device_request(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_path_request(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_name_request(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::remove_device_by_id_request(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_modifiers_request(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::define_modifier_request(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::remove_modifier_request(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_actions_request(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::define_action_request(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::remove_action_request(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::get_defined_mappings_request(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::define_mapping_request(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::change_mapping_request(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::remove_mapping_request(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::is_listening_request(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::start_listening_request(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::stop_listening_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Request_oneof_request::handshake_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::get_devices_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::execute_code_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::define_device_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::remove_device_by_path_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::remove_device_by_name_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::remove_device_by_id_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::get_defined_modifiers_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::define_modifier_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::remove_modifier_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::get_defined_actions_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::define_action_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::remove_action_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::get_defined_mappings_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::define_mapping_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::change_mapping_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::remove_mapping_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::is_listening_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::start_listening_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::stop_listening_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Request_oneof_request::handshake_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::get_devices_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::execute_code_request(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::define_device_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::remove_device_by_path_request(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::remove_device_by_name_request(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::remove_device_by_id_request(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::get_defined_modifiers_request(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::define_modifier_request(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::remove_modifier_request(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::get_defined_actions_request(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::define_action_request(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::remove_action_request(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::get_defined_mappings_request(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::define_mapping_request(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::change_mapping_request(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::remove_mapping_request(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::is_listening_request(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::start_listening_request(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::stop_listening_request(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeRequest>(
                    "handshake_request",
                    Request::has_handshake_request,
                    Request::get_handshake_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesRequest>(
                    "get_devices_request",
                    Request::has_get_devices_request,
                    Request::get_get_devices_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeRequest>(
                    "execute_code_request",
                    Request::has_execute_code_request,
                    Request::get_execute_code_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineDeviceRequest>(
                    "define_device_request",
                    Request::has_define_device_request,
                    Request::get_define_device_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByPathRequest>(
                    "remove_device_by_path_request",
                    Request::has_remove_device_by_path_request,
                    Request::get_remove_device_by_path_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByNameRequest>(
                    "remove_device_by_name_request",
                    Request::has_remove_device_by_name_request,
                    Request::get_remove_device_by_name_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByIdRequest>(
                    "remove_device_by_id_request",
                    Request::has_remove_device_by_id_request,
                    Request::get_remove_device_by_id_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedModifiersRequest>(
                    "get_defined_modifiers_request",
                    Request::has_get_defined_modifiers_request,
                    Request::get_get_defined_modifiers_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineModifierRequest>(
                    "define_modifier_request",
                    Request::has_define_modifier_request,
                    Request::get_define_modifier_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveModifierRequest>(
                    "remove_modifier_request",
                    Request::has_remove_modifier_request,
                    Request::get_remove_modifier_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedActionsRequest>(
                    "get_defined_actions_request",
                    Request::has_get_defined_actions_request,
                    Request::get_get_defined_actions_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineActionRequest>(
                    "define_action_request",
                    Request::has_define_action_request,
                    Request::get_define_action_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveActionRequest>(
                    "remove_action_request",
                    Request::has_remove_action_request,
                    Request::get_remove_action_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedMappingsRequest>(
                    "get_defined_mappings_request",
                    Request::has_get_defined_mappings_request,
                    Request::get_get_defined_mappings_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineMappingRequest>(
                    "define_mapping_request",
                    Request::has_define_mapping_request,
                    Request::get_define_mapping_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChangeMappingRequest>(
                    "change_mapping_request",
                    Request::has_change_mapping_request,
                    Request::get_change_mapping_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveMappingRequest>(
                    "remove_mapping_request",
                    Request::has_remove_mapping_request,
                    Request::get_remove_mapping_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IsListeningRequest>(
                    "is_listening_request",
                    Request::has_is_listening_request,
                    Request::get_is_listening_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartListeningRequest>(
                    "start_listening_request",
                    Request::has_start_listening_request,
                    Request::get_start_listening_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StopListeningRequest>(
                    "stop_listening_request",
                    Request::has_stop_listening_request,
                    Request::get_stop_listening_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Request::new)
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message oneof groups
    pub response: ::std::option::Option<Response_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Response_oneof_response {
    handshake_response(HandshakeResponse),
    get_devices_response(GetDevicesResponse),
    execute_code_response(ExecuteCodeResponse),
    define_device_response(DefineDeviceResponse),
    remove_device_by_path_response(RemoveDeviceByPathResponse),
    remove_device_by_name_response(RemoveDeviceByNameResponse),
    remove_device_by_id_response(RemoveDeviceByIdResponse),
    get_defined_modifiers_response(GetDefinedModifiersResponse),
    define_modifier_response(DefineModifierResponse),
    remove_modifier_response(RemoveModifierResponse),
    get_defined_actions_response(GetDefinedActionsResponse),
    define_action_response(DefineActionResponse),
    remove_action_response(RemoveActionResponse),
    get_defined_mappings_response(GetDefinedMappingsResponse),
    define_mapping_response(DefineMappingResponse),
    change_mapping_response(ChangeMappingResponse),
    remove_mapping_response(RemoveMappingResponse),
    is_listening_response(IsListeningResponse),
    start_listening_response(StartListeningResponse),
    stop_listening_response(StopListeningResponse),
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .HandshakeResponse handshake_response = 1;


    pub fn get_handshake_response(&self) -> &HandshakeResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::handshake_response(ref v)) => v,
            _ => HandshakeResponse::default_instance(),
        }
    }
    pub fn clear_handshake_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_handshake_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::handshake_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake_response(&mut self, v: HandshakeResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::handshake_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake_response(&mut self) -> &mut HandshakeResponse {
        if let ::std::option::Option::Some(Response_oneof_response::handshake_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::handshake_response(HandshakeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::handshake_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake_response(&mut self) -> HandshakeResponse {
        if self.has_handshake_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::handshake_response(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse::new()
        }
    }

    // .GetDevicesResponse get_devices_response = 2;


    pub fn get_get_devices_response(&self) -> &GetDevicesResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_devices_response(ref v)) => v,
            _ => GetDevicesResponse::default_instance(),
        }
    }
    pub fn clear_get_devices_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_devices_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_devices_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_devices_response(&mut self, v: GetDevicesResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::get_devices_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_devices_response(&mut self) -> &mut GetDevicesResponse {
        if let ::std::option::Option::Some(Response_oneof_response::get_devices_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::get_devices_response(GetDevicesResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_devices_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_devices_response(&mut self) -> GetDevicesResponse {
        if self.has_get_devices_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::get_devices_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDevicesResponse::new()
        }
    }

    // .ExecuteCodeResponse execute_code_response = 3;


    pub fn get_execute_code_response(&self) -> &ExecuteCodeResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::execute_code_response(ref v)) => v,
            _ => ExecuteCodeResponse::default_instance(),
        }
    }
    pub fn clear_execute_code_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_execute_code_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::execute_code_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execute_code_response(&mut self, v: ExecuteCodeResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::execute_code_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execute_code_response(&mut self) -> &mut ExecuteCodeResponse {
        if let ::std::option::Option::Some(Response_oneof_response::execute_code_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::execute_code_response(ExecuteCodeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::execute_code_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execute_code_response(&mut self) -> ExecuteCodeResponse {
        if self.has_execute_code_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::execute_code_response(v)) => v,
                _ => panic!(),
            }
        } else {
            ExecuteCodeResponse::new()
        }
    }

    // .DefineDeviceResponse define_device_response = 4;


    pub fn get_define_device_response(&self) -> &DefineDeviceResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_device_response(ref v)) => v,
            _ => DefineDeviceResponse::default_instance(),
        }
    }
    pub fn clear_define_device_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_define_device_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_device_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_device_response(&mut self, v: DefineDeviceResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::define_device_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_device_response(&mut self) -> &mut DefineDeviceResponse {
        if let ::std::option::Option::Some(Response_oneof_response::define_device_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::define_device_response(DefineDeviceResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_device_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_device_response(&mut self) -> DefineDeviceResponse {
        if self.has_define_device_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::define_device_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineDeviceResponse::new()
        }
    }

    // .RemoveDeviceByPathResponse remove_device_by_path_response = 5;


    pub fn get_remove_device_by_path_response(&self) -> &RemoveDeviceByPathResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(ref v)) => v,
            _ => RemoveDeviceByPathResponse::default_instance(),
        }
    }
    pub fn clear_remove_device_by_path_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_device_by_path_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_device_by_path_response(&mut self, v: RemoveDeviceByPathResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_device_by_path_response(&mut self) -> &mut RemoveDeviceByPathResponse {
        if let ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(RemoveDeviceByPathResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_device_by_path_response(&mut self) -> RemoveDeviceByPathResponse {
        if self.has_remove_device_by_path_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByPathResponse::new()
        }
    }

    // .RemoveDeviceByNameResponse remove_device_by_name_response = 6;


    pub fn get_remove_device_by_name_response(&self) -> &RemoveDeviceByNameResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(ref v)) => v,
            _ => RemoveDeviceByNameResponse::default_instance(),
        }
    }
    pub fn clear_remove_device_by_name_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_device_by_name_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_device_by_name_response(&mut self, v: RemoveDeviceByNameResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_device_by_name_response(&mut self) -> &mut RemoveDeviceByNameResponse {
        if let ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(RemoveDeviceByNameResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_device_by_name_response(&mut self) -> RemoveDeviceByNameResponse {
        if self.has_remove_device_by_name_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByNameResponse::new()
        }
    }

    // .RemoveDeviceByIdResponse remove_device_by_id_response = 7;


    pub fn get_remove_device_by_id_response(&self) -> &RemoveDeviceByIdResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(ref v)) => v,
            _ => RemoveDeviceByIdResponse::default_instance(),
        }
    }
    pub fn clear_remove_device_by_id_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_device_by_id_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_device_by_id_response(&mut self, v: RemoveDeviceByIdResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_device_by_id_response(&mut self) -> &mut RemoveDeviceByIdResponse {
        if let ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(RemoveDeviceByIdResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_device_by_id_response(&mut self) -> RemoveDeviceByIdResponse {
        if self.has_remove_device_by_id_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveDeviceByIdResponse::new()
        }
    }

    // .GetDefinedModifiersResponse get_defined_modifiers_response = 8;


    pub fn get_get_defined_modifiers_response(&self) -> &GetDefinedModifiersResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(ref v)) => v,
            _ => GetDefinedModifiersResponse::default_instance(),
        }
    }
    pub fn clear_get_defined_modifiers_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_defined_modifiers_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_defined_modifiers_response(&mut self, v: GetDefinedModifiersResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_defined_modifiers_response(&mut self) -> &mut GetDefinedModifiersResponse {
        if let ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(GetDefinedModifiersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_defined_modifiers_response(&mut self) -> GetDefinedModifiersResponse {
        if self.has_get_defined_modifiers_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedModifiersResponse::new()
        }
    }

    // .DefineModifierResponse define_modifier_response = 9;


    pub fn get_define_modifier_response(&self) -> &DefineModifierResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_modifier_response(ref v)) => v,
            _ => DefineModifierResponse::default_instance(),
        }
    }
    pub fn clear_define_modifier_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_define_modifier_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_modifier_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_modifier_response(&mut self, v: DefineModifierResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::define_modifier_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_modifier_response(&mut self) -> &mut DefineModifierResponse {
        if let ::std::option::Option::Some(Response_oneof_response::define_modifier_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::define_modifier_response(DefineModifierResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_modifier_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_modifier_response(&mut self) -> DefineModifierResponse {
        if self.has_define_modifier_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::define_modifier_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineModifierResponse::new()
        }
    }

    // .RemoveModifierResponse remove_modifier_response = 10;


    pub fn get_remove_modifier_response(&self) -> &RemoveModifierResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(ref v)) => v,
            _ => RemoveModifierResponse::default_instance(),
        }
    }
    pub fn clear_remove_modifier_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_modifier_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_modifier_response(&mut self, v: RemoveModifierResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_modifier_response(&mut self) -> &mut RemoveModifierResponse {
        if let ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(RemoveModifierResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_modifier_response(&mut self) -> RemoveModifierResponse {
        if self.has_remove_modifier_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveModifierResponse::new()
        }
    }

    // .GetDefinedActionsResponse get_defined_actions_response = 11;


    pub fn get_get_defined_actions_response(&self) -> &GetDefinedActionsResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(ref v)) => v,
            _ => GetDefinedActionsResponse::default_instance(),
        }
    }
    pub fn clear_get_defined_actions_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_defined_actions_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_defined_actions_response(&mut self, v: GetDefinedActionsResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_defined_actions_response(&mut self) -> &mut GetDefinedActionsResponse {
        if let ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(GetDefinedActionsResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_defined_actions_response(&mut self) -> GetDefinedActionsResponse {
        if self.has_get_defined_actions_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedActionsResponse::new()
        }
    }

    // .DefineActionResponse define_action_response = 12;


    pub fn get_define_action_response(&self) -> &DefineActionResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_action_response(ref v)) => v,
            _ => DefineActionResponse::default_instance(),
        }
    }
    pub fn clear_define_action_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_define_action_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_action_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_action_response(&mut self, v: DefineActionResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::define_action_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_action_response(&mut self) -> &mut DefineActionResponse {
        if let ::std::option::Option::Some(Response_oneof_response::define_action_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::define_action_response(DefineActionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_action_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_action_response(&mut self) -> DefineActionResponse {
        if self.has_define_action_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::define_action_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineActionResponse::new()
        }
    }

    // .RemoveActionResponse remove_action_response = 13;


    pub fn get_remove_action_response(&self) -> &RemoveActionResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_action_response(ref v)) => v,
            _ => RemoveActionResponse::default_instance(),
        }
    }
    pub fn clear_remove_action_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_action_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_action_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_action_response(&mut self, v: RemoveActionResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::remove_action_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_action_response(&mut self) -> &mut RemoveActionResponse {
        if let ::std::option::Option::Some(Response_oneof_response::remove_action_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::remove_action_response(RemoveActionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_action_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_action_response(&mut self) -> RemoveActionResponse {
        if self.has_remove_action_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::remove_action_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveActionResponse::new()
        }
    }

    // .GetDefinedMappingsResponse get_defined_mappings_response = 14;


    pub fn get_get_defined_mappings_response(&self) -> &GetDefinedMappingsResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(ref v)) => v,
            _ => GetDefinedMappingsResponse::default_instance(),
        }
    }
    pub fn clear_get_defined_mappings_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_defined_mappings_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_defined_mappings_response(&mut self, v: GetDefinedMappingsResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_defined_mappings_response(&mut self) -> &mut GetDefinedMappingsResponse {
        if let ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(GetDefinedMappingsResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_defined_mappings_response(&mut self) -> GetDefinedMappingsResponse {
        if self.has_get_defined_mappings_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(v)) => v,
                _ => panic!(),
            }
        } else {
            GetDefinedMappingsResponse::new()
        }
    }

    // .DefineMappingResponse define_mapping_response = 15;


    pub fn get_define_mapping_response(&self) -> &DefineMappingResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_mapping_response(ref v)) => v,
            _ => DefineMappingResponse::default_instance(),
        }
    }
    pub fn clear_define_mapping_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_define_mapping_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_mapping_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_mapping_response(&mut self, v: DefineMappingResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::define_mapping_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_mapping_response(&mut self) -> &mut DefineMappingResponse {
        if let ::std::option::Option::Some(Response_oneof_response::define_mapping_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::define_mapping_response(DefineMappingResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::define_mapping_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_mapping_response(&mut self) -> DefineMappingResponse {
        if self.has_define_mapping_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::define_mapping_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DefineMappingResponse::new()
        }
    }

    // .ChangeMappingResponse change_mapping_response = 16;


    pub fn get_change_mapping_response(&self) -> &ChangeMappingResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::change_mapping_response(ref v)) => v,
            _ => ChangeMappingResponse::default_instance(),
        }
    }
    pub fn clear_change_mapping_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_change_mapping_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::change_mapping_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_change_mapping_response(&mut self, v: ChangeMappingResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::change_mapping_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_change_mapping_response(&mut self) -> &mut ChangeMappingResponse {
        if let ::std::option::Option::Some(Response_oneof_response::change_mapping_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::change_mapping_response(ChangeMappingResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::change_mapping_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_change_mapping_response(&mut self) -> ChangeMappingResponse {
        if self.has_change_mapping_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::change_mapping_response(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeMappingResponse::new()
        }
    }

    // .RemoveMappingResponse remove_mapping_response = 17;


    pub fn get_remove_mapping_response(&self) -> &RemoveMappingResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(ref v)) => v,
            _ => RemoveMappingResponse::default_instance(),
        }
    }
    pub fn clear_remove_mapping_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_remove_mapping_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_mapping_response(&mut self, v: RemoveMappingResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_mapping_response(&mut self) -> &mut RemoveMappingResponse {
        if let ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(RemoveMappingResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_mapping_response(&mut self) -> RemoveMappingResponse {
        if self.has_remove_mapping_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoveMappingResponse::new()
        }
    }

    // .IsListeningResponse is_listening_response = 18;


    pub fn get_is_listening_response(&self) -> &IsListeningResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::is_listening_response(ref v)) => v,
            _ => IsListeningResponse::default_instance(),
        }
    }
    pub fn clear_is_listening_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_is_listening_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::is_listening_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_is_listening_response(&mut self, v: IsListeningResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::is_listening_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_is_listening_response(&mut self) -> &mut IsListeningResponse {
        if let ::std::option::Option::Some(Response_oneof_response::is_listening_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::is_listening_response(IsListeningResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::is_listening_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_is_listening_response(&mut self) -> IsListeningResponse {
        if self.has_is_listening_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::is_listening_response(v)) => v,
                _ => panic!(),
            }
        } else {
            IsListeningResponse::new()
        }
    }

    // .StartListeningResponse start_listening_response = 19;


    pub fn get_start_listening_response(&self) -> &StartListeningResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::start_listening_response(ref v)) => v,
            _ => StartListeningResponse::default_instance(),
        }
    }
    pub fn clear_start_listening_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_start_listening_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::start_listening_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_listening_response(&mut self, v: StartListeningResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::start_listening_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_listening_response(&mut self) -> &mut StartListeningResponse {
        if let ::std::option::Option::Some(Response_oneof_response::start_listening_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::start_listening_response(StartListeningResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::start_listening_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_listening_response(&mut self) -> StartListeningResponse {
        if self.has_start_listening_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::start_listening_response(v)) => v,
                _ => panic!(),
            }
        } else {
            StartListeningResponse::new()
        }
    }

    // .StopListeningResponse stop_listening_response = 20;


    pub fn get_stop_listening_response(&self) -> &StopListeningResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::stop_listening_response(ref v)) => v,
            _ => StopListeningResponse::default_instance(),
        }
    }
    pub fn clear_stop_listening_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_stop_listening_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::stop_listening_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_listening_response(&mut self, v: StopListeningResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::stop_listening_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop_listening_response(&mut self) -> &mut StopListeningResponse {
        if let ::std::option::Option::Some(Response_oneof_response::stop_listening_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::stop_listening_response(StopListeningResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::stop_listening_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop_listening_response(&mut self) -> StopListeningResponse {
        if self.has_stop_listening_response() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::stop_listening_response(v)) => v,
                _ => panic!(),
            }
        } else {
            StopListeningResponse::new()
        }
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        if let Some(Response_oneof_response::handshake_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::get_devices_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::execute_code_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::define_device_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::remove_device_by_path_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::remove_device_by_name_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::remove_device_by_id_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::get_defined_modifiers_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::define_modifier_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::remove_modifier_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::get_defined_actions_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::define_action_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::remove_action_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::get_defined_mappings_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::define_mapping_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::change_mapping_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::remove_mapping_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::is_listening_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::start_listening_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::stop_listening_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::handshake_response(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::get_devices_response(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::execute_code_response(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::define_device_response(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_path_response(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_name_response(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::remove_device_by_id_response(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_modifiers_response(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::define_modifier_response(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::remove_modifier_response(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_actions_response(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::define_action_response(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::remove_action_response(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::get_defined_mappings_response(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::define_mapping_response(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::change_mapping_response(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::remove_mapping_response(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::is_listening_response(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::start_listening_response(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::stop_listening_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::handshake_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::get_devices_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::execute_code_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::define_device_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::remove_device_by_path_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::remove_device_by_name_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::remove_device_by_id_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::get_defined_modifiers_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::define_modifier_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::remove_modifier_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::get_defined_actions_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::define_action_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::remove_action_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::get_defined_mappings_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::define_mapping_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::change_mapping_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::remove_mapping_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::is_listening_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::start_listening_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::stop_listening_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::handshake_response(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::get_devices_response(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::execute_code_response(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::define_device_response(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::remove_device_by_path_response(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::remove_device_by_name_response(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::remove_device_by_id_response(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::get_defined_modifiers_response(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::define_modifier_response(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::remove_modifier_response(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::get_defined_actions_response(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::define_action_response(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::remove_action_response(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::get_defined_mappings_response(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::define_mapping_response(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::change_mapping_response(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::remove_mapping_response(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::is_listening_response(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::start_listening_response(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::stop_listening_response(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HandshakeResponse>(
                    "handshake_response",
                    Response::has_handshake_response,
                    Response::get_handshake_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDevicesResponse>(
                    "get_devices_response",
                    Response::has_get_devices_response,
                    Response::get_get_devices_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExecuteCodeResponse>(
                    "execute_code_response",
                    Response::has_execute_code_response,
                    Response::get_execute_code_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineDeviceResponse>(
                    "define_device_response",
                    Response::has_define_device_response,
                    Response::get_define_device_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByPathResponse>(
                    "remove_device_by_path_response",
                    Response::has_remove_device_by_path_response,
                    Response::get_remove_device_by_path_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByNameResponse>(
                    "remove_device_by_name_response",
                    Response::has_remove_device_by_name_response,
                    Response::get_remove_device_by_name_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveDeviceByIdResponse>(
                    "remove_device_by_id_response",
                    Response::has_remove_device_by_id_response,
                    Response::get_remove_device_by_id_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedModifiersResponse>(
                    "get_defined_modifiers_response",
                    Response::has_get_defined_modifiers_response,
                    Response::get_get_defined_modifiers_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineModifierResponse>(
                    "define_modifier_response",
                    Response::has_define_modifier_response,
                    Response::get_define_modifier_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveModifierResponse>(
                    "remove_modifier_response",
                    Response::has_remove_modifier_response,
                    Response::get_remove_modifier_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedActionsResponse>(
                    "get_defined_actions_response",
                    Response::has_get_defined_actions_response,
                    Response::get_get_defined_actions_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineActionResponse>(
                    "define_action_response",
                    Response::has_define_action_response,
                    Response::get_define_action_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveActionResponse>(
                    "remove_action_response",
                    Response::has_remove_action_response,
                    Response::get_remove_action_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetDefinedMappingsResponse>(
                    "get_defined_mappings_response",
                    Response::has_get_defined_mappings_response,
                    Response::get_get_defined_mappings_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefineMappingResponse>(
                    "define_mapping_response",
                    Response::has_define_mapping_response,
                    Response::get_define_mapping_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChangeMappingResponse>(
                    "change_mapping_response",
                    Response::has_change_mapping_response,
                    Response::get_change_mapping_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoveMappingResponse>(
                    "remove_mapping_response",
                    Response::has_remove_mapping_response,
                    Response::get_remove_mapping_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IsListeningResponse>(
                    "is_listening_response",
                    Response::has_is_listening_response,
                    Response::get_is_listening_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartListeningResponse>(
                    "start_listening_response",
                    Response::has_start_listening_response,
                    Response::get_start_listening_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StopListeningResponse>(
                    "stop_listening_response",
                    Response::has_stop_listening_response,
                    Response::get_stop_listening_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eprotocol.proto\"+\n\x0eActionKeyPress\x12\x19\n\x08key_code\x18\
    \x01\x20\x01(\x05R\x07keyCode\"+\n\x0eActionKeyClick\x12\x19\n\x08key_co\
    de\x18\x01\x20\x01(\x05R\x07keyCode\"-\n\x10ActionKeyRelease\x12\x19\n\
    \x08key_code\x18\x01\x20\x01(\x05R\x07keyCode\"9\n\x16ActionMouseButtonP\
    ress\x12\x1f\n\x0bbutton_code\x18\x01\x20\x01(\x05R\nbuttonCode\"9\n\x16\
    ActionMouseButtonClick\x12\x1f\n\x0bbutton_code\x18\x01\x20\x01(\x05R\nb\
    uttonCode\";\n\x18ActionMouseButtonRelease\x12\x1f\n\x0bbutton_code\x18\
    \x01\x20\x01(\x05R\nbuttonCode\"/\n\x12ActionTextKeyClick\x12\x19\n\x08k\
    ey_code\x18\x01\x20\x01(\x05R\x07keyCode\"1\n\x14ActionNumberKeyClick\
    \x12\x19\n\x08key_code\x18\x01\x20\x01(\x05R\x07keyCode\"3\n\x16ActionFu\
    nctionKeyClick\x12\x19\n\x08key_code\x18\x01\x20\x01(\x05R\x07keyCode\"2\
    \n\x15ActionControlKeyClick\x12\x19\n\x08key_code\x18\x01\x20\x01(\x05R\
    \x07keyCode\"-\n\x10ActionKPKeyClick\x12\x19\n\x08key_code\x18\x01\x20\
    \x01(\x05R\x07keyCode\"5\n\x18ActionMultimediaKeyClick\x12\x19\n\x08key_\
    code\x18\x01\x20\x01(\x05R\x07keyCode\"6\n\x19ActionMouseButtonKeyClick\
    \x12\x19\n\x08key_code\x18\x01\x20\x01(\x05R\x07keyCode\"9\n\x17ActionMo\
    useRelativeMove\x12\x0e\n\x02dx\x18\x01\x20\x01(\x05R\x02dx\x12\x0e\n\
    \x02dy\x18\x02\x20\x01(\x05R\x02dy\"5\n\x17ActionMouseAbsoluteMove\x12\
    \x0c\n\x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\
    \x05R\x01y\"\x1c\n\nActionWait\x12\x0e\n\x02ms\x18\x01\x20\x01(\x05R\x02\
    ms\"$\n\x0eActionTextType\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\
    \"'\n\x11ActionExecuteCode\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\
    \"<\n\x15ActionExecuteFunction\x12#\n\rfunction_name\x18\x01\x20\x01(\tR\
    \x0cfunctionName\"7\n\x16ActionExecuteOSCommand\x12\x1d\n\nos_command\
    \x18\x01\x20\x01(\tR\tosCommand\";\n\x18ActionExecuteNamedAction\x12\x1f\
    \n\x0baction_name\x18\x01\x20\x01(\tR\nactionName\"\x1f\n\x1dActionExecu\
    teInterpreterValue\"\xee\r\n\x06Action\x12;\n\x10action_key_press\x18\
    \x01\x20\x01(\x0b2\x0f.ActionKeyPressH\0R\x0eactionKeyPress\x12;\n\x10ac\
    tion_key_click\x18\x02\x20\x01(\x0b2\x0f.ActionKeyClickH\0R\x0eactionKey\
    Click\x12A\n\x12action_key_release\x18\x03\x20\x01(\x0b2\x11.ActionKeyRe\
    leaseH\0R\x10actionKeyRelease\x12T\n\x19action_mouse_button_press\x18\
    \x04\x20\x01(\x0b2\x17.ActionMouseButtonPressH\0R\x16actionMouseButtonPr\
    ess\x12T\n\x19action_mouse_button_click\x18\x05\x20\x01(\x0b2\x17.Action\
    MouseButtonClickH\0R\x16actionMouseButtonClick\x12Z\n\x1baction_mouse_bu\
    tton_release\x18\x06\x20\x01(\x0b2\x19.ActionMouseButtonReleaseH\0R\x18a\
    ctionMouseButtonRelease\x12H\n\x15action_text_key_click\x18\x07\x20\x01(\
    \x0b2\x13.ActionTextKeyClickH\0R\x12actionTextKeyClick\x12N\n\x17action_\
    number_key_click\x18\x08\x20\x01(\x0b2\x15.ActionNumberKeyClickH\0R\x14a\
    ctionNumberKeyClick\x12T\n\x19action_function_key_click\x18\t\x20\x01(\
    \x0b2\x17.ActionFunctionKeyClickH\0R\x16actionFunctionKeyClick\x12Q\n\
    \x18action_control_key_click\x18\n\x20\x01(\x0b2\x16.ActionControlKeyCli\
    ckH\0R\x15actionControlKeyClick\x12B\n\x13action_kp_key_click\x18\x0b\
    \x20\x01(\x0b2\x11.ActionKPKeyClickH\0R\x10actionKpKeyClick\x12Z\n\x1bac\
    tion_multimedia_key_click\x18\x0c\x20\x01(\x0b2\x19.ActionMultimediaKeyC\
    lickH\0R\x18actionMultimediaKeyClick\x12^\n\x1daction_mouse_button_key_c\
    lick\x18\r\x20\x01(\x0b2\x1a.ActionMouseButtonKeyClickH\0R\x19actionMous\
    eButtonKeyClick\x12W\n\x1aaction_mouse_relative_move\x18\x0e\x20\x01(\
    \x0b2\x18.ActionMouseRelativeMoveH\0R\x17actionMouseRelativeMove\x12W\n\
    \x1aaction_mouse_absolute_move\x18\x0f\x20\x01(\x0b2\x18.ActionMouseAbso\
    luteMoveH\0R\x17actionMouseAbsoluteMove\x12;\n\x10action_text_type\x18\
    \x10\x20\x01(\x0b2\x0f.ActionTextTypeH\0R\x0eactionTextType\x12.\n\x0bac\
    tion_wait\x18\x11\x20\x01(\x0b2\x0b.ActionWaitH\0R\nactionWait\x12D\n\
    \x13action_execute_code\x18\x12\x20\x01(\x0b2\x12.ActionExecuteCodeH\0R\
    \x11actionExecuteCode\x12P\n\x17action_execute_function\x18\x13\x20\x01(\
    \x0b2\x16.ActionExecuteFunctionH\0R\x15actionExecuteFunction\x12T\n\x19a\
    ction_execute_os_command\x18\x14\x20\x01(\x0b2\x17.ActionExecuteOSComman\
    dH\0R\x16actionExecuteOsCommand\x12Z\n\x1baction_execute_named_action\
    \x18\x15\x20\x01(\x0b2\x19.ActionExecuteNamedActionH\0R\x18actionExecute\
    NamedAction\x12i\n\x20action_execute_interpreter_value\x18\x16\x20\x01(\
    \x0b2\x1e.ActionExecuteInterpreterValueH\0R\x1dactionExecuteInterpreterV\
    alueB\x08\n\x06action\"O\n\x0bNamedAction\x12\x1f\n\x0baction_name\x18\
    \x01\x20\x01(\tR\nactionName\x12\x1f\n\x06action\x18\x02\x20\x01(\x0b2\
    \x07.ActionR\x06action\"/\n\nActionList\x12!\n\x07actions\x18\x01\x20\
    \x03(\x0b2\x07.ActionR\x07actions\"!\n\x04Key1\x12\x19\n\x08key_code\x18\
    \x01\x20\x01(\x05R\x07keyCode\">\n\x04Key2\x12\x1b\n\tdevice_id\x18\x01\
    \x20\x01(\x05R\x08deviceId\x12\x19\n\x08key_code\x18\x02\x20\x01(\x05R\
    \x07keyCode\"H\n\x03Key\x12\x1c\n\x05key_1\x18\x01\x20\x01(\x0b2\x05.Key\
    1H\0R\x04key1\x12\x1c\n\x05key_2\x18\x02\x20\x01(\x0b2\x05.Key2H\0R\x04k\
    ey2B\x05\n\x03key\"C\n\x13ModifierDescription\x12\x16\n\x03key\x18\x01\
    \x20\x01(\x0b2\x04.KeyR\x03key\x12\x14\n\x05alias\x18\x02\x20\x01(\tR\
    \x05alias\"W\n\x08KeyChord\x12\"\n\tmodifiers\x18\x01\x20\x03(\x0b2\x04.\
    KeyR\tmodifiers\x12'\n\x0cordinary_key\x18\x02\x20\x01(\x0b2\x04.KeyR\
    \x0bordinaryKey\"T\n\x07Mapping\x12(\n\nkey_chords\x18\x01\x20\x03(\x0b2\
    \t.KeyChordR\tkeyChords\x12\x1f\n\x06action\x18\x02\x20\x01(\x0b2\x07.Ac\
    tionR\x06action\"u\n\x0eKeyDescription\x12\x0c\n\x01x\x18\x01\x20\x01(\
    \x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\x12\x14\n\x05width\
    \x18\x03\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\x05\
    R\x06height\x12\x19\n\x08key_code\x18\x05\x20\x01(\x05R\x07keyCode\"\x91\
    \x01\n\x0bDeviceModel\x12:\n\x10key_descriptions\x18\x01\x20\x03(\x0b2\
    \x0f.KeyDescriptionR\x0fkeyDescriptions\x12!\n\x0cdevice_width\x18\x02\
    \x20\x01(\x05R\x0bdeviceWidth\x12#\n\rdevice_height\x18\x03\x20\x01(\x05\
    R\x0cdeviceHeight\"\xb6\x01\n\nDeviceInfo\x12\x1b\n\tdevice_id\x18\x01\
    \x20\x01(\x05R\x08deviceId\x12\x18\n\x07defined\x18\x02\x20\x01(\x08R\
    \x07defined\x12\x1f\n\x0bdevice_path\x18\x03\x20\x01(\tR\ndevicePath\x12\
    \x1f\n\x0bdevice_name\x18\x04\x20\x01(\tR\ndeviceName\x12/\n\x0cdevice_m\
    odel\x18\x05\x20\x01(\x0b2\x0c.DeviceModelR\x0bdeviceModel\"\x12\n\x10Ha\
    ndshakeRequest\"\x8b\x03\n\x11HandshakeResponse\x12I\n\x0esuccess_result\
    \x18\x01\x20\x01(\x0b2\x20.HandshakeResponse.SuccessResultH\0R\rsuccessR\
    esult\x12C\n\x0cerror_result\x18\x02\x20\x01(\x0b2\x1e.HandshakeResponse\
    .ErrorResultH\0R\x0berrorResult\x12I\n\x0efailure_result\x18\x03\x20\x01\
    (\x0b2\x20.HandshakeResponse.FailureResultH\0R\rfailureResult\x1a=\n\rSu\
    ccessResult\x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07version\x12\x12\
    \n\x04info\x18\x02\x20\x01(\tR\x04info\x1a'\n\x0bErrorResult\x12\x18\n\
    \x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\
    \n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"\x13\n\
    \x11GetDevicesRequest\"\x91\x03\n\x12GetDevicesResponse\x12J\n\x0esucces\
    s_result\x18\x01\x20\x01(\x0b2!.GetDevicesResponse.SuccessResultH\0R\rsu\
    ccessResult\x12D\n\x0cerror_result\x18\x02\x20\x01(\x0b2\x1f.GetDevicesR\
    esponse.ErrorResultH\0R\x0berrorResult\x12J\n\x0efailure_result\x18\x03\
    \x20\x01(\x0b2!.GetDevicesResponse.FailureResultH\0R\rfailureResult\x1a?\
    \n\rSuccessResult\x12.\n\x0cdevices_info\x18\x01\x20\x03(\x0b2\x0b.Devic\
    eInfoR\x0bdevicesInfo\x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\
    \x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\
    \x01\x20\x01(\tR\x07messageB\x08\n\x06result\"(\n\x12ExecuteCodeRequest\
    \x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\"\xff\x02\n\x13ExecuteCod\
    eResponse\x12K\n\x0esuccess_result\x18\x01\x20\x01(\x0b2\".ExecuteCodeRe\
    sponse.SuccessResultH\0R\rsuccessResult\x12E\n\x0cerror_result\x18\x02\
    \x20\x01(\x0b2\x20.ExecuteCodeResponse.ErrorResultH\0R\x0berrorResult\
    \x12K\n\x0efailure_result\x18\x03\x20\x01(\x0b2\".ExecuteCodeResponse.Fa\
    ilureResultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\x18\n\x07messag\
    e\x18\x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\n\x07mess\
    age\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07me\
    ssage\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"2\n\x13DefineDevi\
    ceRequest\x12\x1b\n\tdevice_id\x18\x01\x20\x01(\x05R\x08deviceId\"\x83\
    \x03\n\x14DefineDeviceResponse\x12L\n\x0esuccess_result\x18\x01\x20\x01(\
    \x0b2#.DefineDeviceResponse.SuccessResultH\0R\rsuccessResult\x12F\n\x0ce\
    rror_result\x18\x02\x20\x01(\x0b2!.DefineDeviceResponse.ErrorResultH\0R\
    \x0berrorResult\x12L\n\x0efailure_result\x18\x03\x20\x01(\x0b2#.DefineDe\
    viceResponse.FailureResultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\
    \x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\
    \x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResu\
    lt\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\
    \"<\n\x19RemoveDeviceByPathRequest\x12\x1f\n\x0bdevice_path\x18\x01\x20\
    \x01(\tR\ndevicePath\"\x9b\x03\n\x1aRemoveDeviceByPathResponse\x12R\n\
    \x0esuccess_result\x18\x01\x20\x01(\x0b2).RemoveDeviceByPathResponse.Suc\
    cessResultH\0R\rsuccessResult\x12L\n\x0cerror_result\x18\x02\x20\x01(\
    \x0b2'.RemoveDeviceByPathResponse.ErrorResultH\0R\x0berrorResult\x12R\n\
    \x0efailure_result\x18\x03\x20\x01(\x0b2).RemoveDeviceByPathResponse.Fai\
    lureResultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\x18\n\x07message\
    \x18\x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\n\x07messa\
    ge\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07mes\
    sage\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"<\n\x19RemoveDevic\
    eByNameRequest\x12\x1f\n\x0bdevice_name\x18\x01\x20\x01(\tR\ndeviceName\
    \"\x9b\x03\n\x1aRemoveDeviceByNameResponse\x12R\n\x0esuccess_result\x18\
    \x01\x20\x01(\x0b2).RemoveDeviceByNameResponse.SuccessResultH\0R\rsucces\
    sResult\x12L\n\x0cerror_result\x18\x02\x20\x01(\x0b2'.RemoveDeviceByName\
    Response.ErrorResultH\0R\x0berrorResult\x12R\n\x0efailure_result\x18\x03\
    \x20\x01(\x0b2).RemoveDeviceByNameResponse.FailureResultH\0R\rfailureRes\
    ult\x1a)\n\rSuccessResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07me\
    ssage\x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07\
    message\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\
    \x07messageB\x08\n\x06result\"6\n\x17RemoveDeviceByIdRequest\x12\x1b\n\t\
    device_id\x18\x01\x20\x01(\x05R\x08deviceId\"\x93\x03\n\x18RemoveDeviceB\
    yIdResponse\x12P\n\x0esuccess_result\x18\x01\x20\x01(\x0b2'.RemoveDevice\
    ByIdResponse.SuccessResultH\0R\rsuccessResult\x12J\n\x0cerror_result\x18\
    \x02\x20\x01(\x0b2%.RemoveDeviceByIdResponse.ErrorResultH\0R\x0berrorRes\
    ult\x12P\n\x0efailure_result\x18\x03\x20\x01(\x0b2'.RemoveDeviceByIdResp\
    onse.FailureResultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\x18\n\
    \x07message\x18\x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\
    \n\x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\
    \x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"\x1c\
    \n\x1aGetDefinedModifiersRequest\"\xd0\x03\n\x1bGetDefinedModifiersRespo\
    nse\x12S\n\x0esuccess_result\x18\x01\x20\x01(\x0b2*.GetDefinedModifiersR\
    esponse.SuccessResultH\0R\rsuccessResult\x12M\n\x0cerror_result\x18\x02\
    \x20\x01(\x0b2(.GetDefinedModifiersResponse.ErrorResultH\0R\x0berrorResu\
    lt\x12S\n\x0efailure_result\x18\x03\x20\x01(\x0b2*.GetDefinedModifiersRe\
    sponse.FailureResultH\0R\rfailureResult\x1aZ\n\rSuccessResult\x12I\n\x15\
    modifier_descriptions\x18\x01\x20\x03(\x0b2\x14.ModifierDescriptionR\x14\
    modifierDescriptions\x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\
    \x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\
    \x01\x20\x01(\tR\x07messageB\x08\n\x06result\"I\n\x15DefineModifierReque\
    st\x120\n\x08modifier\x18\x01\x20\x01(\x0b2\x14.ModifierDescriptionR\x08\
    modifier\"\x8b\x03\n\x16DefineModifierResponse\x12N\n\x0esuccess_result\
    \x18\x01\x20\x01(\x0b2%.DefineModifierResponse.SuccessResultH\0R\rsucces\
    sResult\x12H\n\x0cerror_result\x18\x02\x20\x01(\x0b2#.DefineModifierResp\
    onse.ErrorResultH\0R\x0berrorResult\x12N\n\x0efailure_result\x18\x03\x20\
    \x01(\x0b2%.DefineModifierResponse.FailureResultH\0R\rfailureResult\x1a)\
    \n\rSuccessResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\
    \x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messa\
    ge\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07mes\
    sageB\x08\n\x06result\"@\n\x15RemoveModifierRequest\x12'\n\x0cmodifier_k\
    ey\x18\x01\x20\x01(\x0b2\x04.KeyR\x0bmodifierKey\"\x8b\x03\n\x16RemoveMo\
    difierResponse\x12N\n\x0esuccess_result\x18\x01\x20\x01(\x0b2%.RemoveMod\
    ifierResponse.SuccessResultH\0R\rsuccessResult\x12H\n\x0cerror_result\
    \x18\x02\x20\x01(\x0b2#.RemoveModifierResponse.ErrorResultH\0R\x0berrorR\
    esult\x12N\n\x0efailure_result\x18\x03\x20\x01(\x0b2%.RemoveModifierResp\
    onse.FailureResultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\x18\n\
    \x07message\x18\x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\
    \n\x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\
    \x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"\x1a\
    \n\x18GetDefinedActionsRequest\"\xb0\x03\n\x19GetDefinedActionsResponse\
    \x12Q\n\x0esuccess_result\x18\x01\x20\x01(\x0b2(.GetDefinedActionsRespon\
    se.SuccessResultH\0R\rsuccessResult\x12K\n\x0cerror_result\x18\x02\x20\
    \x01(\x0b2&.GetDefinedActionsResponse.ErrorResultH\0R\x0berrorResult\x12\
    Q\n\x0efailure_result\x18\x03\x20\x01(\x0b2(.GetDefinedActionsResponse.F\
    ailureResultH\0R\rfailureResult\x1aB\n\rSuccessResult\x121\n\rnamed_acti\
    ons\x18\x01\x20\x03(\x0b2\x0c.NamedActionR\x0cnamedActions\x1a'\n\x0bErr\
    orResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFai\
    lureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\
    \x06result\";\n\x13DefineActionRequest\x12$\n\x06action\x18\x01\x20\x01(\
    \x0b2\x0c.NamedActionR\x06action\"\x83\x03\n\x14DefineActionResponse\x12\
    L\n\x0esuccess_result\x18\x01\x20\x01(\x0b2#.DefineActionResponse.Succes\
    sResultH\0R\rsuccessResult\x12F\n\x0cerror_result\x18\x02\x20\x01(\x0b2!\
    .DefineActionResponse.ErrorResultH\0R\x0berrorResult\x12L\n\x0efailure_r\
    esult\x18\x03\x20\x01(\x0b2#.DefineActionResponse.FailureResultH\0R\rfai\
    lureResult\x1a)\n\rSuccessResult\x12\x18\n\x07message\x18\x01\x20\x01(\t\
    R\x07message\x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\
    \tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\
    \x01(\tR\x07messageB\x08\n\x06result\"6\n\x13RemoveActionRequest\x12\x1f\
    \n\x0baction_name\x18\x01\x20\x01(\tR\nactionName\"\x83\x03\n\x14RemoveA\
    ctionResponse\x12L\n\x0esuccess_result\x18\x01\x20\x01(\x0b2#.RemoveActi\
    onResponse.SuccessResultH\0R\rsuccessResult\x12F\n\x0cerror_result\x18\
    \x02\x20\x01(\x0b2!.RemoveActionResponse.ErrorResultH\0R\x0berrorResult\
    \x12L\n\x0efailure_result\x18\x03\x20\x01(\x0b2#.RemoveActionResponse.Fa\
    ilureResultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\x18\n\x07messag\
    e\x18\x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\n\x07mess\
    age\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07me\
    ssage\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"\x1b\n\x19GetDefi\
    nedMappingsRequest\"\xa7\x03\n\x1aGetDefinedMappingsResponse\x12R\n\x0es\
    uccess_result\x18\x01\x20\x01(\x0b2).GetDefinedMappingsResponse.SuccessR\
    esultH\0R\rsuccessResult\x12L\n\x0cerror_result\x18\x02\x20\x01(\x0b2'.G\
    etDefinedMappingsResponse.ErrorResultH\0R\x0berrorResult\x12R\n\x0efailu\
    re_result\x18\x03\x20\x01(\x0b2).GetDefinedMappingsResponse.FailureResul\
    tH\0R\rfailureResult\x1a5\n\rSuccessResult\x12$\n\x08mappings\x18\x01\
    \x20\x03(\x0b2\x08.MappingR\x08mappings\x1a'\n\x0bErrorResult\x12\x18\n\
    \x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\
    \n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\":\n\x14De\
    fineMappingRequest\x12\"\n\x07mapping\x18\x01\x20\x01(\x0b2\x08.MappingR\
    \x07mapping\"\x87\x03\n\x15DefineMappingResponse\x12M\n\x0esuccess_resul\
    t\x18\x01\x20\x01(\x0b2$.DefineMappingResponse.SuccessResultH\0R\rsucces\
    sResult\x12G\n\x0cerror_result\x18\x02\x20\x01(\x0b2\".DefineMappingResp\
    onse.ErrorResultH\0R\x0berrorResult\x12M\n\x0efailure_result\x18\x03\x20\
    \x01(\x0b2$.DefineMappingResponse.FailureResultH\0R\rfailureResult\x1a)\
    \n\rSuccessResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\
    \x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messa\
    ge\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07mes\
    sageB\x08\n\x06result\"a\n\x14ChangeMappingRequest\x12(\n\nkey_chords\
    \x18\x01\x20\x03(\x0b2\t.KeyChordR\tkeyChords\x12\x1f\n\x06action\x18\
    \x02\x20\x01(\x0b2\x07.ActionR\x06action\"\x87\x03\n\x15ChangeMappingRes\
    ponse\x12M\n\x0esuccess_result\x18\x01\x20\x01(\x0b2$.ChangeMappingRespo\
    nse.SuccessResultH\0R\rsuccessResult\x12G\n\x0cerror_result\x18\x02\x20\
    \x01(\x0b2\".ChangeMappingResponse.ErrorResultH\0R\x0berrorResult\x12M\n\
    \x0efailure_result\x18\x03\x20\x01(\x0b2$.ChangeMappingResponse.FailureR\
    esultH\0R\rfailureResult\x1a)\n\rSuccessResult\x12\x18\n\x07message\x18\
    \x01\x20\x01(\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\n\x07message\
    \x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07messa\
    ge\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"@\n\x14RemoveMapping\
    Request\x12(\n\nkey_chords\x18\x01\x20\x03(\x0b2\t.KeyChordR\tkeyChords\
    \"\x87\x03\n\x15RemoveMappingResponse\x12M\n\x0esuccess_result\x18\x01\
    \x20\x01(\x0b2$.RemoveMappingResponse.SuccessResultH\0R\rsuccessResult\
    \x12G\n\x0cerror_result\x18\x02\x20\x01(\x0b2\".RemoveMappingResponse.Er\
    rorResultH\0R\x0berrorResult\x12M\n\x0efailure_result\x18\x03\x20\x01(\
    \x0b2$.RemoveMappingResponse.FailureResultH\0R\rfailureResult\x1a)\n\rSu\
    ccessResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a'\n\
    \x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a)\
    \n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\
    \x08\n\x06result\"\x14\n\x12IsListeningRequest\"\x88\x03\n\x13IsListenin\
    gResponse\x12K\n\x0esuccess_result\x18\x01\x20\x01(\x0b2\".IsListeningRe\
    sponse.SuccessResultH\0R\rsuccessResult\x12E\n\x0cerror_result\x18\x02\
    \x20\x01(\x0b2\x20.IsListeningResponse.ErrorResultH\0R\x0berrorResult\
    \x12K\n\x0efailure_result\x18\x03\x20\x01(\x0b2\".IsListeningResponse.Fa\
    ilureResultH\0R\rfailureResult\x1a2\n\rSuccessResult\x12!\n\x0cis_listen\
    ing\x18\x01\x20\x01(\x08R\x0bisListening\x1a'\n\x0bErrorResult\x12\x18\n\
    \x07message\x18\x01\x20\x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\
    \n\x07message\x18\x01\x20\x01(\tR\x07messageB\x08\n\x06result\"\x17\n\
    \x15StartListeningRequest\"\x8b\x03\n\x16StartListeningResponse\x12N\n\
    \x0esuccess_result\x18\x01\x20\x01(\x0b2%.StartListeningResponse.Success\
    ResultH\0R\rsuccessResult\x12H\n\x0cerror_result\x18\x02\x20\x01(\x0b2#.\
    StartListeningResponse.ErrorResultH\0R\x0berrorResult\x12N\n\x0efailure_\
    result\x18\x03\x20\x01(\x0b2%.StartListeningResponse.FailureResultH\0R\r\
    failureResult\x1a)\n\rSuccessResult\x12\x18\n\x07message\x18\x01\x20\x01\
    (\tR\x07message\x1a'\n\x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\
    \x01(\tR\x07message\x1a)\n\rFailureResult\x12\x18\n\x07message\x18\x01\
    \x20\x01(\tR\x07messageB\x08\n\x06result\"\x16\n\x14StopListeningRequest\
    \"\x87\x03\n\x15StopListeningResponse\x12M\n\x0esuccess_result\x18\x01\
    \x20\x01(\x0b2$.StopListeningResponse.SuccessResultH\0R\rsuccessResult\
    \x12G\n\x0cerror_result\x18\x02\x20\x01(\x0b2\".StopListeningResponse.Er\
    rorResultH\0R\x0berrorResult\x12M\n\x0efailure_result\x18\x03\x20\x01(\
    \x0b2$.StopListeningResponse.FailureResultH\0R\rfailureResult\x1a)\n\rSu\
    ccessResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a'\n\
    \x0bErrorResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x1a)\
    \n\rFailureResult\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messageB\
    \x08\n\x06result\"\xfb\x0c\n\x07Request\x12@\n\x11handshake_request\x18\
    \x01\x20\x01(\x0b2\x11.HandshakeRequestH\0R\x10handshakeRequest\x12D\n\
    \x13get_devices_request\x18\x02\x20\x01(\x0b2\x12.GetDevicesRequestH\0R\
    \x11getDevicesRequest\x12G\n\x14execute_code_request\x18\x03\x20\x01(\
    \x0b2\x13.ExecuteCodeRequestH\0R\x12executeCodeRequest\x12J\n\x15define_\
    device_request\x18\x04\x20\x01(\x0b2\x14.DefineDeviceRequestH\0R\x13defi\
    neDeviceRequest\x12^\n\x1dremove_device_by_path_request\x18\x05\x20\x01(\
    \x0b2\x1a.RemoveDeviceByPathRequestH\0R\x19removeDeviceByPathRequest\x12\
    ^\n\x1dremove_device_by_name_request\x18\x06\x20\x01(\x0b2\x1a.RemoveDev\
    iceByNameRequestH\0R\x19removeDeviceByNameRequest\x12X\n\x1bremove_devic\
    e_by_id_request\x18\x07\x20\x01(\x0b2\x18.RemoveDeviceByIdRequestH\0R\
    \x17removeDeviceByIdRequest\x12`\n\x1dget_defined_modifiers_request\x18\
    \x08\x20\x01(\x0b2\x1b.GetDefinedModifiersRequestH\0R\x1agetDefinedModif\
    iersRequest\x12P\n\x17define_modifier_request\x18\t\x20\x01(\x0b2\x16.De\
    fineModifierRequestH\0R\x15defineModifierRequest\x12P\n\x17remove_modifi\
    er_request\x18\n\x20\x01(\x0b2\x16.RemoveModifierRequestH\0R\x15removeMo\
    difierRequest\x12Z\n\x1bget_defined_actions_request\x18\x0b\x20\x01(\x0b\
    2\x19.GetDefinedActionsRequestH\0R\x18getDefinedActionsRequest\x12J\n\
    \x15define_action_request\x18\x0c\x20\x01(\x0b2\x14.DefineActionRequestH\
    \0R\x13defineActionRequest\x12J\n\x15remove_action_request\x18\r\x20\x01\
    (\x0b2\x14.RemoveActionRequestH\0R\x13removeActionRequest\x12]\n\x1cget_\
    defined_mappings_request\x18\x0e\x20\x01(\x0b2\x1a.GetDefinedMappingsReq\
    uestH\0R\x19getDefinedMappingsRequest\x12M\n\x16define_mapping_request\
    \x18\x0f\x20\x01(\x0b2\x15.DefineMappingRequestH\0R\x14defineMappingRequ\
    est\x12M\n\x16change_mapping_request\x18\x10\x20\x01(\x0b2\x15.ChangeMap\
    pingRequestH\0R\x14changeMappingRequest\x12M\n\x16remove_mapping_request\
    \x18\x11\x20\x01(\x0b2\x15.RemoveMappingRequestH\0R\x14removeMappingRequ\
    est\x12G\n\x14is_listening_request\x18\x12\x20\x01(\x0b2\x13.IsListening\
    RequestH\0R\x12isListeningRequest\x12P\n\x17start_listening_request\x18\
    \x13\x20\x01(\x0b2\x16.StartListeningRequestH\0R\x15startListeningReques\
    t\x12M\n\x16stop_listening_request\x18\x14\x20\x01(\x0b2\x15.StopListeni\
    ngRequestH\0R\x14stopListeningRequestB\t\n\x07request\"\xb9\r\n\x08Respo\
    nse\x12C\n\x12handshake_response\x18\x01\x20\x01(\x0b2\x12.HandshakeResp\
    onseH\0R\x11handshakeResponse\x12G\n\x14get_devices_response\x18\x02\x20\
    \x01(\x0b2\x13.GetDevicesResponseH\0R\x12getDevicesResponse\x12J\n\x15ex\
    ecute_code_response\x18\x03\x20\x01(\x0b2\x14.ExecuteCodeResponseH\0R\
    \x13executeCodeResponse\x12M\n\x16define_device_response\x18\x04\x20\x01\
    (\x0b2\x15.DefineDeviceResponseH\0R\x14defineDeviceResponse\x12a\n\x1ere\
    move_device_by_path_response\x18\x05\x20\x01(\x0b2\x1b.RemoveDeviceByPat\
    hResponseH\0R\x1aremoveDeviceByPathResponse\x12a\n\x1eremove_device_by_n\
    ame_response\x18\x06\x20\x01(\x0b2\x1b.RemoveDeviceByNameResponseH\0R\
    \x1aremoveDeviceByNameResponse\x12[\n\x1cremove_device_by_id_response\
    \x18\x07\x20\x01(\x0b2\x19.RemoveDeviceByIdResponseH\0R\x18removeDeviceB\
    yIdResponse\x12c\n\x1eget_defined_modifiers_response\x18\x08\x20\x01(\
    \x0b2\x1c.GetDefinedModifiersResponseH\0R\x1bgetDefinedModifiersResponse\
    \x12S\n\x18define_modifier_response\x18\t\x20\x01(\x0b2\x17.DefineModifi\
    erResponseH\0R\x16defineModifierResponse\x12S\n\x18remove_modifier_respo\
    nse\x18\n\x20\x01(\x0b2\x17.RemoveModifierResponseH\0R\x16removeModifier\
    Response\x12]\n\x1cget_defined_actions_response\x18\x0b\x20\x01(\x0b2\
    \x1a.GetDefinedActionsResponseH\0R\x19getDefinedActionsResponse\x12M\n\
    \x16define_action_response\x18\x0c\x20\x01(\x0b2\x15.DefineActionRespons\
    eH\0R\x14defineActionResponse\x12M\n\x16remove_action_response\x18\r\x20\
    \x01(\x0b2\x15.RemoveActionResponseH\0R\x14removeActionResponse\x12`\n\
    \x1dget_defined_mappings_response\x18\x0e\x20\x01(\x0b2\x1b.GetDefinedMa\
    ppingsResponseH\0R\x1agetDefinedMappingsResponse\x12P\n\x17define_mappin\
    g_response\x18\x0f\x20\x01(\x0b2\x16.DefineMappingResponseH\0R\x15define\
    MappingResponse\x12P\n\x17change_mapping_response\x18\x10\x20\x01(\x0b2\
    \x16.ChangeMappingResponseH\0R\x15changeMappingResponse\x12P\n\x17remove\
    _mapping_response\x18\x11\x20\x01(\x0b2\x16.RemoveMappingResponseH\0R\
    \x15removeMappingResponse\x12J\n\x15is_listening_response\x18\x12\x20\
    \x01(\x0b2\x14.IsListeningResponseH\0R\x13isListeningResponse\x12S\n\x18\
    start_listening_response\x18\x13\x20\x01(\x0b2\x17.StartListeningRespons\
    eH\0R\x16startListeningResponse\x12P\n\x17stop_listening_response\x18\
    \x14\x20\x01(\x0b2\x16.StopListeningResponseH\0R\x15stopListeningRespons\
    eB\n\n\x08responseb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
